
  <html>
    <head>
      <link href='https://huytd.github.io/css/hack.css' rel='stylesheet' />
      <style>
        body { 
          padding: 50px; 
          margin: 0 auto; 
          width: 700px; 
        } 
        .toc {
          margin: 0 !important;
          padding-left: 20px !important;
        }
        .toc li { 
          padding-left: 20px !important; 
          margin: 5px 0 5px 0 !important;
        } 
        .toc li::after {
          content: "" !important;
        }
      </style>
    </head>
    <body class='hack'>
      <i>Published: Sat Mar 11 2017 18:13:09 GMT-0800 (PST)</i>
      <br/>
      <h1>Table of Contents</h1><li class='toc-item'><a href='#pointers-and-memory-safety'> Pointers and Memory safety</a></li><ul class='toc'><li class='toc-item'><a href='#pointers-and-references'>1. Pointers and references</a></li><ul class='toc'><li class='toc-item'><a href='#the-stack-and-the-heap'>1.1. The stack and the heap</a></li><li class='toc-item'><a href='#lifetimes'>1.2. Lifetimes</a></li></ul></ul>
      <h1 id="pointers-and-memory-safety">Pointers and Memory safety</h1>
<p>The topics will be covered in this post:</p>
<ul>
<li>Pointers and references</li>
<li>Ownership and borrowing</li>
<li>Boxes</li>
<li>Reference counting</li>
</ul>
<h2 id="pointers-and-references">Pointers and references</h2>
<p>Let&#39;s take a step back and talking about stack and heap and some other things first.</p>
<h3 id="the-stack-and-the-heap">The stack and the heap</h3>
<p>By default, a <code>2 MB</code> chunk of memory called stack will be granted to a program when it starts.</p>
<p>The program will use this stack to store all its local variables and function parameters.</p>
<p>When program calls a function, a new <code>stack frame</code> is allocated to it.</p>
<p>By doing this, the stack knows the order in which the functions are called to return correctly to the calling code.</p>
<p><strong>Dynamically sized types</strong> such as <code>strings</code> or <code>arrays</code> can&#39;t be stored in stack. It must be stored in heap. So they&#39;re potentially much bigger piece of memory than the stack.</p>
<h3 id="lifetimes">Lifetimes</h3>
<p>All variables in Rust have a lifetime.</p>
<p>A value of a variable is valid from where it is declared to when it is no longer referenced, this called <em>the lifetime of a variable</em>.</p>
<pre><code>fn main() {
  let n = 42u32;
  let n2 = n; // a copy of the value from n to n2
  life(n);
  println!(&quot;{}&quot;, m);  // error: unresolved name `m`.
  println!(&quot;{}&quot;, o);  // error: unresolved name `o`.
}

fn life(m: u32) -&gt; u32 {
  let o = m;
  o
}
</code></pre><p>The lifetime of <code>n</code> ends when <code>main()</code> ends. In other words, the start and end of a lifetime happen in the same scope.</p>
<p>The words <code>lifetime</code> and <code>scope</code> are synonymous, but <code>lifetime</code> is used to refer to the <em>extent of a reference</em>.</p>
<p>The lifetime of a value can be indicated by an annotation <code>&#39;a</code>. It can be <code>&#39;b</code>, <code>&#39;n</code> or <code>&#39;life</code>, but its common to use a single character to represent lifetimes.</p>
<pre><code>fn fun&lt;&#39;a&gt;(s: &amp;&#39;a str) {
  ...
}
</code></pre><p>The <code>&#39;static</code> lifetime is the lifetime of things that last for the entire length of the program. Only use <code>&#39;static</code> when you need the value that long.</p>
<p>In the example of <code>fun()</code> function above, we can opt-out the lifetime <code>&lt;&#39;a&gt;</code> because the compiler is smart enough to recognize it.</p>

    </body>
  </html>
  