<html><head><link href='https://huytd.github.io/css/hack.css' rel='stylesheet' /><style>body { padding: 50px; margin: 0 auto; width: 700px; }</style></head><body class='hack'><i>Published: Sat Mar 04 2017 03:04:39 GMT-0800 (PST)</i><br/><h1 id="receiving-and-returning-vector-in-rust-ffi">Receiving and returning Vector in Rust FFI</h1>
<p>There is one thing we need to know when working with FFI is: <strong>Not all Rust&#39;s types are returnable through FFI</strong>.</p>
<p>For example:</p>
<pre><code>fn getVec() -&gt; *const *const c_char {
  let s = vec![ &quot;Hello&quot;, &quot;Yo&quot; ];
  return s.as_ptr();
}
</code></pre><p>The <code>s</code> vector will be freed at the end of <code>getVec()</code> function. So the returned pointer <code>s.as_ptr()</code> will just points to a freed memory. This will cause segfaults in Node or Ruby (or whereever you use the FFI module).</p>
<p>The solution for this is get the pointer of <code>s</code> then tell Rust to just <code>forget</code> about <code>s</code>:</p>
<pre><code>fn getVec() -&gt; *const *const c_char {
  let s = vec![ &quot;Hello&quot;, &quot;Yo&quot; ];
  let r = s.as_ptr();  // &lt;== save the pointer
  std::mem::forget(s); // &lt;== forget the s
  return r;
}
</code></pre><p>You may surprised but it&#39;s obiviously that <code>mem::forget</code> is safe in Rust, it doesn&#39;t need to be wrapped in <code>unsafe</code> block.</p>
<p>The reason is, it&#39;s ok to leak some memory in Rust. Not calling the destructor of a value is not something that violate the Rust safey rules.</p>
<p>But leaking memory or I/O objects is usually undesirable, so use <code>forget</code> for specialized use cases only.</p>
</body></html>