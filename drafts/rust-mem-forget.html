
  <html>
    <head>
      <link href='https://huytd.github.io/css/hack.css' rel='stylesheet' />
      <style>
        body { 
          padding: 50px; 
          margin: 0 auto; 
          width: 700px; 
        } 
        .toc {
          margin: 0 !important;
          padding-left: 20px !important;
        }
        .toc li { 
          padding-left: 20px !important; 
          margin: 5px 0 5px 0 !important;
        } 
        .toc li::after {
          content: "" !important;
        }
      </style>
    </head>
    <body class='hack'>
      <i>Published: Sat Mar 11 2017 18:13:09 GMT-0800 (PST)</i>
      <br/>
      
      <h1 id="rust-s-std-mem-forget">Rust&#39;s std::mem::forget</h1>
<p><code>std::mem::forget</code> is used when you want to keep the value from being automatically freed by Rust.</p>
<p>What it does is: Take the ownership and forget about the value <strong>without running its destructor</strong>.</p>
<p>It&#39;s really helpful if you&#39;re using <a href="rust-ffi-c.html">FFI</a> and need to return a pointer to something that might be freed by Rust automatically.</p>
<p>For example:</p>
<pre><code>fn getVec() -&gt; *const *const c_char {
  let s = vec![ &quot;Hello&quot;, &quot;Yo&quot; ];
  return s.as_ptr();
}
</code></pre><p>The <code>s</code> vector will be freed at the end of <code>getVec()</code> function. So the returned pointer <code>s.as_ptr()</code> will just points to a freed memory. This will cause segfaults in Node or Ruby (or whereever you use the FFI module).</p>
<p>The solution for this is get the pointer of <code>s</code> then tell Rust to just <code>forget</code> about <code>s</code>:</p>
<pre><code>fn getVec() -&gt; *const *const c_char {
  let s = vec![ &quot;Hello&quot;, &quot;Yo&quot; ];
  let r = s.as_ptr();  // &lt;== save the pointer
  std::mem::forget(s); // &lt;== forget the s
  return r;
}
</code></pre><p>You may surprised but it&#39;s obiviously that <code>mem::forget</code> is safe in Rust, it doesn&#39;t need to be wrapped in <code>unsafe</code> block.</p>
<p>The reason is, it&#39;s ok to leak some memory in Rust. Not calling the destructor of a value is not something that violate the Rust safey rules.</p>
<p>But leaking memory or I/O objects is usually undesirable, so use <code>forget</code> for specialized use cases only.</p>

    </body>
  </html>
  