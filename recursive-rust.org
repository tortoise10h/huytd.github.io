#+TITLE: Recursive type problem in Rust
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/hack.css" />
#+HTML_HEAD: <script async src="https://www.googletagmanager.com/gtag/js?id=UA-121604637-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-121604637-1'); </script>
#+HTML_LINK_HOME: /
#+OPTIONS: toc:nil

After spending much time reading about Rust, I decided to [[https://github.com/huytd/thingsinrust/blob/master/binary_tree/binary_tree.rs][give it a try]].

#+attr_html: :width 500px
[[https://cdn-images-1.medium.com/max/2000/1*UNsRZHTPh1rO1eF_VH71gw.png]]

It was a very simple implementation of **Binary Tree Traversal** algorithm.
Surprisingly, by doing it, I learned a lot of Rust’s basic concepts!

* Rust tell us what’s wrong in our code

One of the first things that the smartass Rust compiler threw to my face was the lovely error message:

#+BEGIN_SRC 
$ rustc binary_tree.rs -o binary_tree
error[E0072]: recursive type `Node` has infinite size
  --> binary_tree.rs:1:1
  |
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Node` representable
error: aborting due to previous error

So yes, this is the code:

struct Node {
    value: i32,
    left: Option<Node>,
    right: Option<Node>
}
#+END_SRC

This code is a very obvious way to implement a binary tree node in other
programming languages like C/C++ or Java. However, Rust compiler just doesn’t agree with us. Also, this is the interesting part.

Take a closer look. The error message said that our **Node** struct is a
**recursive type** and it has infinite size. What does it mean?

In Rust, all values are allocated in stack by default. So the compiler needs to
know the size of each. The size of a struct is the sum of all its fields size.

For example, with this struct:

#+BEGIN_SRC 
struct Point {
    x: i32,
    y: u8
}
#+END_SRC

So the size of Point struct is:

#+BEGIN_SRC 
size_of::<Point>() == size_of::<i32>() + size_of::<u8>()
#+END_SRC

Back to our implementation, how do we calculate our Node’s size?

#+BEGIN_SRC 
size_of::<i32>() + 2 * size_of::<Option>() + 2 * size_of::<Node>()
#+END_SRC

Let’s expand this equation:

#+attr_html: :width 600px
[[https://cdn-images-1.medium.com/max/1600/1*rV3hH3Yq-KkS7d5sVYYCog.png]]

Hey hey! Hey! Stop it! You can do this for all day long. There’s no way to stop the expanding process.

So, the size of **Node** would be infinite and become impossible for Rust
compiler to calculate.

* And Rust also tell us how to fix it

Let’s take a look at the error message again. You can see the kindness of Rust when it tries to teach us how to repair the broken:

#+BEGIN_SRC 
$ rustc binary_tree.rs -o binary_tree

error[E0072]: recursive type `Node` has infinite size
  --> binary_tree.rs:1:1
  |
1 | struct Node {
  | ^ recursive type has infinite size
  |

error: aborting due to previous error
#+END_SRC

If we follow the hint and add **Box<T>** to our implementation, the problem will be solved:

#+BEGIN_SRC 
struct Node {
    value: i32,
    left: Option<Box<Node>>,
    right: Option<Box<Node>>
}
#+END_SRC

However, what is ~Box<T>~? How does it solve our recursive reference problem?

~Box<T>~ is a **pointer** that pointed to a heap allocated memory space.

So when we declare a reference to ~Node~ using ~Box<Node>~, *the size of this reference is the size of a pointer*, not the size of the ~Node~ type, and it is defined, so Rust compiler now aware how much memory needed to allocate for a ~Node~. And the recursive type problem now solved!

-----

I hope you enjoy the post and now understand the problem of recursive type, how to fix it.

Please feel free to leave a comment if you want to discuss or subscribe to my blog to keep updated about my next posts in Rust (and other technical stuff, of course).
