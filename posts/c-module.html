<html>
    <head>
        <title> Thiết kế hướng Module trong C | Huy's Blog</title>
        <meta charset="utf-8">
        <meta http-equiv="content-type" content="text/html;"><meta name=viewport content="initial-scale=1.0 maximum-scale=1.0">
        
        <link href="../css/inconsolata.css" rel="stylesheet" type="text/css">
        <link href="../css/theme.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="../css/highlight/tomorrow.css">
        <link rel="stylesheet" href="../css/fontello.css">
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/autosizing.js"></script>
        <script>
        hljs.initHighlightingOnLoad();
        </script>
    </head>
    <body>
      <div class="notice">Nội dung trên blog này được cập nhật lần cuối vào lúc <b>11:50 02/05/2017</b>.<br/>Từ giờ blog sẽ chuyển sang nhà mới là <a href="https://thefullsnack.com">https://thefullsnack.com</a>. Mong các bạn ghé chơi <i class="icon icon-emo-coffee"></i></div>
        <div class="header">
            <a href="/"><i class="icon icon-emo-coffee"></i> Huy's Blog</a>
        </div>
        <div class="container">
            <div class="main">
                <h1 id="thi-t-k-h-ng-module-trong-c">Thiết kế hướng Module trong C</h1>
<p>C có lẽ là một ngôn ngữ không lạ đối với tất cả mọi người, nhất là các bạn sinh viên các năm đầu và các bạn học sinh cấp 3, vì đây là quãng thời gian chúng ta sử dụng C nhiều nhất -- để giải bài tập.</p>
<p>Tuy nhiên sẽ thế nào nếu chúng ta sử dụng C và áp dụng vào công việc thực tế? lưu ý ở đây mình nói về C chứ không phải C++ nhé. Cụ thể là phát triển các ứng dụng lớn bằng C? nghe có vẻ điên rồ quá không? </p>
<h2 id="c-ai-l-m-v-y-kh-ng-">Có ai làm vậy không?</h2>
<p>Câu trả lời là có. Rất nhiều là đằng khác. Để xem ai nào...</p>
<p>Đầu tiên phải kể đến đó là <a href="https://github.com/torvalds/linux">nhân hệ điều hành Linux</a> và <a href="https://github.com/git/git">git</a>, cả 2 sản phẩm quan trọng này đều được viết hoàn toàn bằng <strong>C</strong> bởi <strong>Linus Torvalds</strong> và đây là một <a href="http://harmful.cat-v.org/software/c++/linus">C++ hater có tiếng</a>.</p>
<p>Kế đến có thể nói đến <a href="https://github.com/curl/curl">curl</a>, công cụ mà bất cứ ai xài hệ điều hành unix-like như các thể loại Linux hay macOS đều từng xài qua, cũng được viết chủ yếu bằng <strong>C</strong>.</p>
<p>Trong thế giới của các web developer, có thể kể đến <a href="https://github.com/antirez/redis">redis</a>, <a href="https://github.com/nginx/nginx">nginx</a>, <a href="https://github.com/openssl/openssl">openssl</a> đều được viết bằng <strong>C</strong>.</p>
<p>Chưa hết, ngoài ra còn có <a href="https://github.com/libuv/libuv">libuv</a>, bộ thư viện đứng đằng sau sự thành công của cơ chế Async I/O tạo nên tên tuổi của NodeJS (tất nhiên chỉ là trong giới frontend dev thôi =)))) cũng được xây dựng bằng <strong>C</strong> nốt.</p>
<p>Ồ, còn nữa, ngay cả ngôn ngữ <a href="https://github.com/ruby/ruby">ruby</a> vốn đã quá nổi tiếng không cần nói thêm nữa, cũng được Matz xây dựng bằng <strong>C</strong> luôn đấy.</p>
<p>Phèo, kể nhiều mỏi tay quá, viết đến đây tự dưng cảm thấy gần như toàn bộ thế giới đã được xây dựng bằng <strong>C</strong> rồi, tại sao mình lại lang thang đi code Swift với Java làm gì nhỉ 🐔</p>
<h2 id="ok-v-y-gi-v-ch-ch-nh-i-">OK, vậy giờ vô chủ đề chính đi...</h2>
<p>Bây giờ chúng ta sẽ cùng tìm hiểu làm thế nào để viết được các ứng dụng lớn như những ví dụ đã nêu ở trên, chỉ bằng cách sử dụng một ngôn ngữ không hề có những chức năng gì tiêu biểu như là class, hay template,... như C.</p>
<p>Thông thường, khi viết một chương trình C thì chúng ta sẽ thực hiện như mô hình sau:</p>
<p><img src="img/write-C-old.png" alt=""></p>
<p>Chương trình được viết tại file <strong>main.c</strong> và sau khi biên dịch, chúng ta có một file binary có thể chạy được, định dạng file này như thế nào là tùy vào hệ điều hành đích mà chúng ta chỉ định để biên dịch.</p>
<p>Chương trình càng lớn, file <strong>main.c</strong> càng to, thời gian biên dịch càng chậm, đó là lý do tại sao chúng ta nên phân tách ra thành từng module nhỏ, thao tác này gọi là Modularity.</p>
<h3 id="modularity-l-g-">Modularity là gì?</h3>
<p>Modularity là phương pháp tổ chức một chương trình lớn thành nhiều phần nhỏ hơn, gọi là từng <strong>module</strong>. Mỗi module sẽ gồm một file <strong>header (*.h)</strong> chứa các định nghĩa, khai báo biến, prototype, các kiểu,... và một file <strong>implementation (*.c)</strong> để hiện thực hóa các prototype trong header, mục đích chính là để giấu đi phần code thực sự của nó và giấu luôn các thuộc tính private của từng module.</p>
<p><img src="img/write-C-module.png" alt=""></p>
<p>Ở phần sau chúng ta sẽ nói rõ hơn về cách tổ chức bên trong một module. </p>
<p>Sơ đồ bên dưới cho chúng ta thấy cách tổ chức của một project sử dụng nhiều module:</p>
<p><img src="img/write-C-module-layout.png" alt=""></p>
<p>Trong sơ đồ này, chúng ta có 2 module <code>mod_a</code> và <code>mod_b</code> được khai báo bằng các file .h và .c tương ứng. Khi biên dịch, các module này sẽ được trình biên dịch build thành các file <strong>mod_a.o</strong> và <strong>mod_b.o</strong></p>
<p>Mũi tên màu xanh nước biển chỉ quá trình biên dịch, mũi tên màu xanh lục chỉ quá trình <strong>Linking</strong>.</p>
<div class="box-white" style="padding: 15px;">
<strong>Side note</strong><br/><hr/>
<strong>Hỏi:</strong> Một chương trình C được biên dịch như thế nào?<br/>
<strong>Đáp:</strong> Một chương trình C được biên dịch thông qua 4 bước: <strong>Pre-processing</strong>, <strong>Compilation</strong>, <strong>Assembly</strong> và <strong>Linking</strong><br/>
<img src="img/c-compilation.png" alt="">
Bước <strong>pre-processing</strong> có nhiệm vụ ghép nối toàn bộ các file header được include, các macro,... thành một bộ source thống nhất và chuyển qua bước <strong>compilation</strong>, bước này, trình biên dịch sẽ &quot;dịch&quot; file source, chuyển nó thành mã máy (assembler code), bước <strong>assembly</strong> nhận chương trình assembler từ bước 2, build thành từng file <strong>object (*.o)</strong>, các file object này sẽ được chuyển qua <strong>linker</strong> (một công cụ giúp kết nối các file object) và tạo thành một file thực thi duy nhất để chạy.
</div>

<h3 id="l-i-ch-c-a-modularity-l-g-">Lợi ích của Modularity là gì?</h3>
<p>Việc phân chia chương trình ra thành nhiều module có rất nhiều ưu điểm, đặc biệt là đối với những ứng dụng lớn và phức tạp:</p>
<ul>
<li>Các module có thể được sử dụng lại trong nhiều project khác</li>
<li>Nếu phần implementation của module có thay đổi, mà không làm thay đổi interface nó cung cấp thì không cần thiết phải compile lại toàn bộ chương trình (chỉ compile module đó thôi)</li>
<li>Compile lại nhanh hơn (như đã nói ở trên)</li>
<li>Self-documenting - Chỉ cần nhìn vào file header thì sẽ biết được cách dùng và các chức năng mà module cung cấp </li>
<li>Dễ debug. Vì tách biệt và hoạt động độc lập nên mỗi module có thể được test riêng biệt, debug riêng biệt.</li>
<li>Một số trình biên dịch C hiện đại có thể generate code nhanh hơn và tối ưu tốt hơn khi chúng ta modularity.</li>
</ul>
<h3 id="modularity-nh-th-n-o-">Modularity như thế nào?</h3>
<p>Modularity tức là chúng ta chia source code thành nhiều file module, mỗi module gồm một file source (.c) và header (.h). </p>
<p>File header sẽ chứa mọi thành phần <strong>public</strong> của module, như là các hằng số, thuộc tính, các hàm chúng ta muốn sử dụng (chỉ khai báo ở dạng prototype), tuyệt đối không implement bên trong file header.</p>
<p><img src="img/write-C-headers.png" alt=""></p>
<p>Các thành phần khác như implementation, các thành phần <strong>private</strong> sẽ được đưa vào source file (.c), vì khi thiết kế theo module, các chương trình/module cần sử dụng module đang xét không cần thiết phải biết phần logic bên dưới của module này làm gì.</p>
<h4 id="header-file-c-g-">Header file có gì?</h4>
<p>Bước đầu tiên khi thiết kế một module đó là tổ chức file Header của module đó.</p>
<p>File header ngoài mục đích định nghĩa các thành phần cần thiết cho quá trình pre-processing, nó còn có tác dụng làm công cụ tham chiếu cho các lập trình viên khác khi sử dụng module của bạn.</p>
<p>Cấu trúc một file header thường có các phần sau:</p>
<h5 id="copyright">Copyright</h5>
<p>Phần này không nhất thiết phải có, nhưng nếu làm các dự án open source thì bạn nên bổ sung các thông tin này, để tránh việc nhập nhằng về quyền sở hữu cũng như việc sử dụng cho các project khác:</p>
<pre><code>/*
  mod_a.h -- Example of a C module
  Copyright 2016 by Huy Tran
  License: MIT
  Author: Huy Tran &lt;huy@gamarist.com&gt;
  Version: 2016-11-16
*/
</code></pre><p>Các thông tin gồm có: Tên module, chú thích cho module, copyright, tên loại giấy phép (rất quan trọng), tên tác giả, version,...</p>
<p>Có nhiều người còn đưa hẳn nội dung giấy phép sử dụng vào phần header này luôn, tuy nhiên theo mình việc này không cần thiết lắm, vì tên giấy phép là đủ rồi.</p>
<h5 id="ch-ng-double-include">Chống double include</h5>
<p>Phần tiếp theo, khá là quan trọng, đó là define module flag để đánh dấu cho C pre-processor biết rằng module đã được xử lý, tránh việc include nhiều lần cùng một file.</p>
<pre><code>#ifndef _MODA_H_
#define _MODA_H_

// Body here

#endif
</code></pre><p>Khối lệnh trên dùng lệnh <code>#ifndef</code> để kiểm tra xem flag <code>_MODA_H_</code> đã tồn tại hay chưa, ban đầu thì chưa.</p>
<p>Nếu chưa tồn tại thì sẽ define flag này bằng lệnh <code>#define</code>, và kết thúc với lệnh <code>#endif</code>.</p>
<p>Sau khi pre-processor xử lý xong file header này, thì flag <code>_MODA_H_</code> cũng đã được tạo xong, nếu lần sau có một module nào đó tình cờ include lại file header này, hoặc bạn vô tình include 2 lần liên tiếp ở nhiều nơi, thì cũng sẽ không bị lỗi khi xử lý.</p>
<h5 id="khai-b-o-macro-h-ng-s-">Khai báo macro, hằng số</h5>
<p>Tiếp theo, chúng ta dùng lệnh <code>#define</code> để khai báo các macro cần dùng cho chương trình, ở đây thì tùy module cần gì và define cho hợp lý.</p>
<p>Ví dụ:</p>
<pre><code>/* mod_a.h -- Constants declarations */

#define MODA_HEX_RED   0xff0000
#define MODA_HEX_GREEN 0x00ff00
#define MODA_HEX_BLUE  0x0000ff

#define MODA_KEY_A     65
</code></pre><p>Lưu ý là các macro, hằng số được khai báo trong file header sẽ là public và tồn tại trong toàn bộ chương trình sử dụng nó, vì thế nên tránh đặt những tên macro dễ gây nhặp nhằng, chồng chéo với các module khác. </p>
<p>Cách tốt nhất là đặt tên theo dạng <code>&lt;Tên Module&gt;_&lt;Macro&gt;</code>.</p>
<h5 id="khai-b-o-ki-u">Khai báo kiểu</h5>
<p>Phần này chúng ta khai báo các kiểu dữ liệu, struct, enum cần dùng cho module.</p>
<pre><code>/* mod_a.h -- Types declarations */

enum moda_direction {
  MODA_NORTH,
  MODA_EAST,
  MODA_SOUTH,
  MODA_WEST
};

typedef struct _moda_point {
  int x;
  int y;
} moda_point;
</code></pre><p>Cách đặt tên cũng tương tự như ở trên.</p>
<h5 id="function-prototype">Function prototype</h5>
<p>Đây là phần quan trọng nhất trong một module header, tại đây chúng ta khai báo toàn bộ prototype của các phương thức/hàm cần dùng bên trong module. Các lập trình viên khác có thể dựa vào file này để sử dụng module của bạn mà không cần phải viết tài liệu chi tiết.</p>
<pre><code>/* mod_a.h -- Function prototypes */

void moda_init(void);
int moda_add(int a);
</code></pre><h4 id="source-file-c-g-">Source file có gì?</h4>
<p>Source file (ví dụ: <strong>mod_a.c</strong>) sẽ là phần implementation cho toàn bộ các prototype function đã khai báo ở header. Tất nhiên là bạn phải include header file trước:</p>
<pre><code>#include &quot;mod_a.h&quot;
</code></pre><p>Ở trong này bạn cũng cần khai báo giá trị cho tất cả các biến đã khai báo ở header (nếu có).</p>
<p>Các macro, hằng số, kiểu dữ liệu được định nghĩa bên trong source file sẽ không được export khi biên dịch, vì thế chúng luôn là <strong>private</strong>.</p>
<p>Các biến số khai báo trong này vẫn sẽ là public trừ khi bạn thêm vào từ khóa <strong>static</strong> cho nó ở phía trước:</p>
<pre><code>static int _a = 1;
</code></pre><p>Tương tự với các hàm, bạn cũng sẽ cần từ khóa <strong>static</strong>, nếu không nó vẫn sẽ được export và các module khác có thể sử dụng, cho dù bạn không khai báo trong prototype:</p>
<pre><code>static void mod_a_private_func(int a, int b) {
  ...
}
</code></pre><hr>
<p><strong>Lưu ý: Ở đây có sự nhập nhằng trong cách dùng từ khóa static</strong></p>
<p>Trong C, nếu ta dùng từ khóa <strong>static</strong> bên trong một scope nào đó khi khai báo một biến, thì ra khỏi scope đó, biến này vẫn tồn tại, vì khi đó nó được cấp phát tĩnh trong bộ nhớ, ví dụ:</p>
<pre><code>void static_test() {
  int a = 0;
  static int b = 0;
  b++;
  printf(&quot;%d -- %d\n&quot;, a, b);
}

static_test();
static_test();
static_test();
</code></pre><p>Output sẽ là:</p>
<pre><code>0 -- 1
0 -- 2
0 -- 3
</code></pre><p>Nhưng nếu dùng nó ở phạm vi toàn cục (không thuộc scope nào) thì trình biên dịch sẽ nhận biết đó là một biến/hàm public.</p>
<pre><code>static void rust_lang() {
  // ...
}
</code></pre><hr>
<h4 id="bi-n-d-ch-b-ng-make">Biên dịch bằng Make</h4>
<h3 id="common-practice-khi-modularity">Common practice khi Modularity</h3>
<h4 id="ki-m-tra-module-export-c-i-g-ra-ngo-i-">Kiểm tra module export cái gì ra ngoài?</h4>
<h4 id="c-ch-t-tr-n-trong-module">Cách đặt trên trong module</h4>
<h4 id="gi-i-quy-t-v-n-ch-ng-ch-o-module">Giải quyết vấn đề chồng chéo module</h4>

                <div class="copyright">
                Bạn được tùy ý bấm like, trích dẫn hoặc copy, post lại, nhưng vui lòng ghi rõ nguồn và tác giả và không làm thay đổi nội dung bài viết. Nếu không làm vậy, mình hy vọng từ nay về sau bạn sẽ luôn cảm thấy cắn rứt lương tâm, ăn không ngon, ngủ không yên. 😆
                </div>
                <!-- Comment -->
                <div class="comments">
                  <div id="comment-loading" class="loading"></div>
                  <div id="login-box" class="login">
                    Bạn cần <button onclick="login()">Login</button> để comment
                  </div>
                  <div id="comment-box" class="comment-input">
                    <div class="avatar">
                      <img id="user-avatar" src="" width="32" height="32"/>
                    </div>
                    <div class="input">
                      <textarea id="comment-content" onkeyup="autoSizing(this)" onkeydown="submitComment(event)" placeholder="Comment gõ vào đây :D"></textarea>
                      <span>Gõ xong nhấn <kbd>Ctrl</kbd> + <kbd>Enter</kbd> để gửi.</span>
                    </div>
                  </div>
                  <ul id="comment-list" class="comment-list"></ul>
                </div>
                <!-- End Comment -->
            </div>
        </div>
	    <div class="footer">
        <p><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://thefullsnack.com/img/by-nc-sa.png" /></a></p>
            <p>Created with <a href="http://github.com/huytd/azeroth-js">azeroth.js</a></p>
            <div class="social">
                <a target="_blank" href="http://facebook.com/kingbazoka"><i class="icon-facebook-squared"></i></a>
                <a target="_blank" href="http://twitter.com/huydotnet"><i class="icon-twitter-squared"></i></a>
                <a target="_blank" href="http://github.com/huytd"><i class="icon-github-squared"></i></a>
                <a target="_blank" href="https://thefullsnack.com"><i class="icon-emo-coffee"></i></a>
            </div>
        </div>
        <script type="text/javascript" async src="https://cdn.rawgit.com/mathjax/MathJax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            skipTags: ["script","noscript","style","textarea"]
          }
        });
        </script>
        <script src="https://www.gstatic.com/firebasejs/3.8.0/firebase.js"></script>
        <script>
          // Initialize Firebase
          var config = {
            apiKey: "AIzaSyA1PnIAlJJ-U6iQJMNnCOknBuziBqGMYcY",
            authDomain: "huys-blog-comment.firebaseapp.com",
            databaseURL: "https://huys-blog-comment.firebaseio.com",
            projectId: "huys-blog-comment",
            storageBucket: "huys-blog-comment.appspot.com",
            messagingSenderId: "317330376829"
          };
          firebase.initializeApp(config);
        </script>
        <script>
          let provider = new firebase.auth.GoogleAuthProvider();
          let auth = firebase.auth();
          let currentUser = null;
          let postCommentURL = 'posts/c-module/comments';

          auth.onAuthStateChanged(function(user) {
            document.getElementById("comment-loading").style.display = "none";
            if (user) {
              currentUser = user;
              // Logged in
              document.getElementById("login-box").style.display = "none";
              document.getElementById("comment-box").style.display = "flex";
              document.getElementById("user-avatar").setAttribute("src", user.photoURL);
            } else {
              // Not login yet
              document.getElementById("comment-box").style.display = "none";
              document.getElementById("login-box").style.display = "block";
            }
          });

          const login = function() {
            auth.signInWithPopup(provider)
              .then(function(result) {
              }).catch(function(err) {
              });
          };

          const encodeHTML = function(s) {
            return s.replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/>/g, '&gt;');
          };

          const saveNewComment = function(comment) {
            if (!currentUser) {
              return;
            }
            let commentData = {
              user: currentUser.displayName,
              avatar: currentUser.photoURL,
              time: (new Date()).getTime(),
              message: encodeHTML(comment)
            };
            database.ref(postCommentURL).push(commentData);
            document.getElementById("comment-content").value = "";
          };

          const submitComment = function(e) {
            let keyCode = e.which || e.keyCode;
            let ctrlCode = e.ctrlKey || e.metaKey;
            if (keyCode === 13 && ctrlCode) {
              let comment = document.getElementById("comment-content").value;
              saveNewComment(comment);
            }
          };

          const filterURLinComment = function(comment) {
            return comment.replace(/(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g, "<a target='_blank' rel='noopener noreferrer' href='$1'>$1</a>");
          };

          const addNewComment = function(user, avatar, time, comment) {
            let commentFiltered = encodeHTML(comment);
            commentFiltered = filterURLinComment(commentFiltered);
            let d = new Date(time);
            let commentTime = d.toLocaleTimeString() + ' ' + d.toLocaleDateString();
            let html = '<div class="avatar">' +
              '   <img src="' + avatar + '" width="32" height="32"/>' +
              ' </div>' +
              '<div class="comment">' +
              '  <div class="metadata"><b>' + user + '</b> lúc <span>' + commentTime + '</span></div>' +
              '  <div class="content">' + commentFiltered
              '  </div>' +
              '</div>';
            let li = document.createElement('li');
            li.innerHTML = html;
            document.getElementById("comment-list").append(li);
          };

          let database = firebase.database();
          let posts = database.ref(postCommentURL).orderByChild('time');
          posts.on('child_added', function(data) {
            addNewComment(data.val().user, data.val().avatar, data.val().time, data.val().message);
          });
        </script>
    </body>
</html>
