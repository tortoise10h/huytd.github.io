<html>
    <head>
        <title> GPU programming với Golang | Huy's Blog</title>
        <meta charset="utf-8">
        <meta http-equiv="content-type" content="text/html;"><meta name=viewport content="initial-scale=1.0 maximum-scale=1.0">
        
        <link href="../css/inconsolata.css" rel="stylesheet" type="text/css">
        <link href="../css/theme.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="../css/highlight/tomorrow.css">
        <link rel="stylesheet" href="../css/fontello.css">
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/autosizing.js"></script>
        <script>
        hljs.initHighlightingOnLoad();
        </script>
    </head>
    <body>
        <div class="header">
            <a href="/"><i class="icon icon-emo-coffee"></i> Huy's Blog</a>
        </div>
        <div class="container">
            <div class="main">
                <h1 id="gpu-programming-v-i-golang">GPU programming với Golang</h1>
<p>Ở <a href="https://huytd.github.io/posts/nhan-ma-tran-2.html">bài trước</a> mình có giới thiệu về kĩ thuật lập trình GPU với <strong>OpenCL</strong> bằng <strong>C/C++</strong>. Hôm nay mình sẽ giới thiệu tiếp kĩ thuật này trên Go.</p>
<p><img src="https://archive.fosdem.org/2014/schedule/event/hpc_devroom_go/hpc_devroom_go-99c7a0bca25373a544f8d99c7e42526e04c7578bcfa3c45fc3be59fa1ada99ba.png" alt=""></p>
<h2 id="s-d-ng-c-c-trong-go">Sử dụng C/C++ trong Go</h2>
<p>Một đặc điểm của Golang là chúng ta có thể thoải mái import các thư viện C/C++ và biên dịch bằng sự hỗ trợ của <strong>Cgo</strong>, các bác có thể xem lại bài <a href="https://huytd.github.io/posts/vai-dieu-ve-cgo.html">Một số kinh nghiệm làm việc với Cgo</a> để biết thêm chi tiết.</p>
<p>Về cách sử dụng thì chúng ta chỉ đơn giản là viết đoạn code <strong>C/C++</strong> trong phần comment đầu file và biên dịch:</p>
<pre><code>package main

/*
#include &lt;stdio.h&gt;

void sayHello() {
  printf(&quot;YOLO!&quot;)
}
*/
import &quot;C&quot;

func main() {
  C.sayHello()
}
</code></pre><p>Cho nên chúng ta hoàn toàn có thể include thư viện <strong>OpenCL</strong> từ bên phía <strong>C/C++</strong> vào Go để chạy bằng Cgo. Tất nhiên phải chỉ định framework cần dùng ở đầu chương trình luôn, ví dụ:</p>
<pre><code>/*
#cgo CFLAGS: -Wall
#cgo LDFLAGS: -framework opencl
#include &lt;OpenCL/opencl.h&gt;
*/
</code></pre><p>Hoặc với <strong>CUDA</strong> như sau:</p>
<pre><code>//#include &lt;cuda.h&gt;
//#cgo LDFLAGS: -lcuda
</code></pre><p>Và viết code cho <strong>Host Program</strong> như bình thường.</p>
<h2 id="kernel-program">Kernel Program</h2>
<p>Bạn có thể lập trình cho <strong>Host Program</strong> bằng Golang, tuy nhiên, đối với <strong>Kernel Program</strong> thì nó vẫn là một file <code>.cl</code> và nó vẫn phải dùng cú pháp của <strong>C</strong>, hoàn toàn không có sự thay đổi nào ở đây cả.</p>
<h2 id="s-d-ng-go-wrappers">Sử dụng Go Wrappers</h2>
<p>Nếu cảm thấy việc khai báo cú pháp theo <strong>Cgo</strong> là hơi phức tạp và gây rối cho chương trình thì bạn có thể sử dụng các wrapper có sẵn mà cộng đồng Golang đã xây dựng, bản chất các wrapper này vẫn là sử dụng <strong>Cgo</strong> không có gì khác, chúng chỉ cung cấp cho bạn cú pháp dễ nhìn hơn và dễ build hơn mà thôi.</p>
<h3 id="cuda-wrapper-cho-go">CUDA Wrapper cho Go</h3>
<p>Bài viết này không có ý định tìm hiểu sâu hơn về <strong>CUDA</strong> cho nên mình sẽ dẫn link để các bạn tham khảo. </p>
<p>Tác giả Arne Vansteenkiste có viết một thư viện tên là <a href="http://mumax.github.io/index.html">$mumax^{3}$</a> hỗ trợ lập trình GPU bằng <strong>CUDA</strong>, các bạn không nhất thiết phải sử dụng <strong>MuMax</strong> tuy nhiên có thể sử dụng <strong>CUDA</strong> wrapper mà <strong>MuMax</strong> cung cấp.</p>
<pre><code>package main

import &quot;github.com/mumax/3/cuda&quot;

func main(){
  N := 3
  a := cuda.NewSlice(N)
  b := cuda.NewSlice(N)
  c := cuda.NewSlice(N)
  defer a.Free()
  defer b.Free()
  defer c.Free()

  a.CopyHtoD([]float32{0, -1, -2})
  b.CopyHtoD([]float32{0, 1, 4})

  cfg := Make1DConfig(N)
  add_kernel(a.Ptr(), b.Ptr(), c.Ptr(), cfg)

  fmt.Println(&quot;result:&quot;, a.HostCopy())
}
</code></pre><p>Ngoài ra các bạn có thể tham khảo thêm slide <a href="https://hpcugent.github.io/easybuild/files/FOSDEM14/FOSDEM14_HPC_devroom_14_GoCUDA.pdf"><strong>Scientific GPU computing with Go</strong></a> để biết thêm chi tiết về framework này.</p>
<h3 id="opencl">OpenCL</h3>
<p>Với <strong>OpenCL</strong> thì chúng ta cũng có kha khá là nhiều các wrapper, tuy nhiên ở đây mình chọn sử dụng <a href="https://github.com/go-gl/cl"><strong>go-gl/cl</strong></a> vì dự án này được phát triển khá là nghiêm túc và rất active, tài liệu + community đầy đủ. </p>
<p>Cách sử dụng thì rất đơn giản, đầu tiên bạn chỉ cần cài đặt gói <strong>go-gl/cl</strong> mới nhất, hoặc là bản stable nhất (là bản v1.2):</p>
<pre><code>go get github.com/go-gl/cl/v1.2/cl
</code></pre><p>Hoặc có thể download và compile lại gói này với lệnh sau để đạt performance tốt hơn:</p>
<pre><code>go install -gcflags=&quot;-l -l -l -l&quot; github.com/go-gl/cl/v1.2/cl
</code></pre><p>Lệnh trên sẽ inline hầu hết mọi function trong package <strong>go-gl/cl</strong> và vì việc gọi function thì rất tốn kém (<a href="http://dave.cheney.net/2014/06/07/five-things-that-make-go-fast">xem ở đây</a>), nên inline sẽ giúp giảm thiểu chi phí cho vụ này, tuy nhiên nhược điểm của cách này là dung lượng binary khi build sẽ lớn hơn nhiều.</p>
<p>Cách dùng thì chỉ cần import thư viện trên vào code, và gọi hàm thông qua đối tượng <code>cl</code>:</p>
<pre><code>import &quot;github.com/go-gl/cl/v1.2/cl&quot;
...
cl.CreateKernel(program, cl.Str(&quot;hello&quot;), errptr)
</code></pre><p>Các bạn có thể xem qua đoạn chương trình mẫu <a href="https://github.com/go-gl/cl/blob/master/sample/square/square.go">tính bình phương một số</a> để hiểu thêm về cách dùng, cũng tương tự như với C/C++:</p>
<p>Mình lượt bỏ các phần linh tinh và ghi lại các phần chính cần lưu ý trong chương trình:</p>
<p>Import thư viện <strong>go-gl/cl</strong>:</p>
<pre><code>package main

import &quot;github.com/go-gl/cl/v1.2/cl&quot;
</code></pre><p>Khai báo và biên dịch <strong>Kernel</strong>:</p>
<pre><code>var KernelSource = `
__kernel void square(
   __global float* input,
   __global float* output,
   const unsigned int count)
{
   int i = get_global_id(0);
   if(i &lt; count)
       output[i] = input[i] * input[i];
}` + &quot;\x00&quot;

...


// Đọc và biên dịch kernel program
srcptr := cl.Str(KernelSource)
program := cl.CreateProgramWithSource(context, 1, &amp;srcptr, nil, errptr)
defer cl.ReleaseProgram(program)

err = cl.BuildProgram(program, 1, &amp;device, nil, nil, nil)
</code></pre><p>Lấy thông tin <strong>Compute Device</strong>:</p>
<pre><code>err := cl.GetDeviceIDs(nil, cl.DEVICE_TYPE_GPU, 1, &amp;device, nil)
</code></pre><p>Khởi tạo <strong>Context</strong>:</p>
<pre><code>context := cl.CreateContext(nil, 1, &amp;device, nil, nil, errptr)
defer cl.ReleaseContext(context)
</code></pre><p>Khởi tạo <strong>Command Queue</strong>:</p>
<pre><code>cq := cl.CreateCommandQueue(context, device, 0, errptr)
defer cl.ReleaseCommandQueue(cq)
</code></pre><p>Khởi tạo <strong>Kernel Object</strong>:</p>
<pre><code>kernel := cl.CreateKernel(program, cl.Str(&quot;square&quot;+&quot;\x00&quot;), errptr)
defer cl.ReleaseKernel(kernel)
</code></pre><p>Khởi tạo <strong>Memory Object</strong>:</p>
<pre><code>input := cl.CreateBuffer(context, cl.MEM_READ_ONLY, 4*DataSize, nil, errptr)
defer cl.ReleaseMemObject(input)

output := cl.CreateBuffer(context, cl.MEM_WRITE_ONLY, 4*DataSize, nil, errptr)
defer cl.ReleaseMemObject(output)
</code></pre><p>Ghi dữ liệu vào <strong>Memory Object</strong> trong <strong>Device</strong>:</p>
<pre><code>err = cl.EnqueueWriteBuffer(cq, input, cl.TRUE, 0, 4*DataSize, unsafe.Pointer(&amp;data[0]), 0, nil, nil)
err = cl.SetKernelArg(kernel, 0, 8, unsafe.Pointer(&amp;input))
err = cl.SetKernelArg(kernel, 1, 8, unsafe.Pointer(&amp;output))
err = cl.SetKernelArg(kernel, 2, 4, unsafe.Pointer(&amp;count))
</code></pre><p>Khởi tạo <strong>Work Group</strong> để bắt đầu chạy <strong>Kernel</strong>: </p>
<pre><code>err = cl.GetKernelWorkGroupInfo(kernel, device, cl.KERNEL_WORK_GROUP_SIZE, 8, unsafe.Pointer(&amp;local), nil)
err = cl.EnqueueNDRangeKernel(cq, kernel, 1, nil, &amp;global, &amp;local, 0, nil, nil)
cl.Finish(cq)
</code></pre><p>Đọc dữ liệu ra bằng <strong>Channel</strong>:</p>
<pre><code>results := make([]float32, DataSize)
err = cl.EnqueueReadBuffer(cq, output, cl.TRUE, 0, 4*1024, unsafe.Pointer(&amp;results[0]), 0, nil, nil)
</code></pre><p>Ở chương trình trên thì có sự xuất hiện của kí tự <code>\x00</code> ở phần <code>kernel source</code>, đây là kí tự <a href="https://en.m.wikipedia.org/wiki/Null_character">NULL</a> dùng để báo hiệu kết thúc string. </p>
<p>Và chúng ta cũng thấy, ở đây ta có thể tận dụng luôn các chức năng mà Go cung cấp một cách rất hiệu quả như là <code>defer</code> hoặc <code>channel</code>,...</p>
<div class='other-tags'><b>Tags:</b> <a class='topic-tag' href='https://huytd.github.io/tags/gpu.html'>gpu</a><a class='topic-tag' href='https://huytd.github.io/tags/golang.html'>golang</a><a class='topic-tag' href='https://huytd.github.io/tags/algorithm.html'>algorithm</a><a class='topic-tag' href='https://huytd.github.io/tags/math.html'>math</a></div>
                <div class="copyright">
                Bạn được tùy ý bấm like, trích dẫn hoặc copy, post lại, nhưng vui lòng ghi rõ nguồn và tác giả và không làm thay đổi nội dung bài viết. Nếu không làm vậy, mình hy vọng từ nay về sau bạn sẽ luôn cảm thấy cắn rứt lương tâm, ăn không ngon, ngủ không yên. 😆
                </div>
                <!-- Comment -->
                <div class="comments">
                  <div id="comment-loading" class="loading"></div>
                  <div id="login-box" class="login">
                    Bạn cần <button onclick="login()">Login</button> để comment
                  </div>
                  <div id="comment-box" class="comment-input">
                    <div class="avatar">
                      <img id="user-avatar" src="" width="32" height="32"/>
                    </div>
                    <div class="input">
                      <textarea id="comment-content" onkeyup="autoSizing(this)" onkeydown="submitComment(event)" placeholder="Comment gõ vào đây :D"></textarea>
                      <span>Gõ xong nhấn <kbd>Ctrl</kbd> + <kbd>Enter</kbd> để gửi.</span>
                    </div>
                  </div>
                  <ul id="comment-list" class="comment-list"></ul>
                </div>
                <!-- End Comment -->
            </div>
        </div>
	    <div class="footer">
            <p>Created with <a href="http://github.com/huytd/azeroth-js">azeroth.js</a></p>
            <div class="social">
                <a target="_blank" href="http://facebook.com/kingbazoka"><i class="icon-facebook-squared"></i></a>
                <a target="_blank" href="http://twitter.com/huydotnet"><i class="icon-twitter-squared"></i></a>
                <a target="_blank" href="http://github.com/huytd"><i class="icon-github-squared"></i></a>
                <a target="_blank" href="https://thefullsnack.com"><i class="icon-emo-coffee"></i></a>
            </div>
        </div>
        <script type="text/javascript" async src="https://cdn.rawgit.com/mathjax/MathJax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            skipTags: ["script","noscript","style","textarea"]
          }
        });
        </script>
        <script src="https://www.gstatic.com/firebasejs/3.8.0/firebase.js"></script>
        <script>
          // Initialize Firebase
          var config = {
            apiKey: "AIzaSyA1PnIAlJJ-U6iQJMNnCOknBuziBqGMYcY",
            authDomain: "huys-blog-comment.firebaseapp.com",
            databaseURL: "https://huys-blog-comment.firebaseio.com",
            projectId: "huys-blog-comment",
            storageBucket: "huys-blog-comment.appspot.com",
            messagingSenderId: "317330376829"
          };
          firebase.initializeApp(config);
        </script>
        <script>
          let provider = new firebase.auth.GoogleAuthProvider();
          let auth = firebase.auth();
          let currentUser = null;
          let postCommentURL = 'posts/go-opencl/comments';

          auth.onAuthStateChanged(function(user) {
            document.getElementById("comment-loading").style.display = "none";
            if (user) {
              currentUser = user;
              // Logged in
              document.getElementById("login-box").style.display = "none";
              document.getElementById("comment-box").style.display = "flex";
              document.getElementById("user-avatar").setAttribute("src", user.photoURL);
            } else {
              // Not login yet
              document.getElementById("comment-box").style.display = "none";
              document.getElementById("login-box").style.display = "block";
            }
          });

          const login = function() {
            auth.signInWithPopup(provider)
              .then(function(result) {
              }).catch(function(err) {
              });
          };

          const encodeHTML = function(s) {
            return s.replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/>/g, '&gt;');
          };

          const saveNewComment = function(comment) {
            if (!currentUser) {
              return;
            }
            let commentData = {
              user: currentUser.displayName,
              avatar: currentUser.photoURL,
              time: (new Date()).getTime(),
              message: encodeHTML(comment)
            };
            database.ref(postCommentURL).push(commentData);
            document.getElementById("comment-content").value = "";
          };

          const submitComment = function(e) {
            let keyCode = e.which || e.keyCode;
            let ctrlCode = e.ctrlKey || e.metaKey;
            if (keyCode === 13 && ctrlCode) {
              let comment = document.getElementById("comment-content").value;
              saveNewComment(comment);
            }
          };

          const filterURLinComment = function(comment) {
            return comment.replace(/(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g, "<a target='_blank' rel='noopener noreferrer' href='$1'>$1</a>");
          };

          const addNewComment = function(user, avatar, time, comment) {
            let commentFiltered = encodeHTML(comment);
            commentFiltered = filterURLinComment(commentFiltered);
            let d = new Date(time);
            let commentTime = d.toLocaleTimeString() + ' ' + d.toLocaleDateString();
            let html = '<div class="avatar">' +
              '   <img src="' + avatar + '" width="32" height="32"/>' +
              ' </div>' +
              '<div class="comment">' +
              '  <div class="metadata"><b>' + user + '</b> lúc <span>' + commentTime + '</span></div>' +
              '  <div class="content">' + commentFiltered
              '  </div>' +
              '</div>';
            let li = document.createElement('li');
            li.innerHTML = html;
            document.getElementById("comment-list").append(li);
          };

          let database = firebase.database();
          let posts = database.ref(postCommentURL).orderByChild('time');
          posts.on('child_added', function(data) {
            addNewComment(data.val().user, data.val().avatar, data.val().time, data.val().message);
          });
        </script>
    </body>
</html>
