<html>
    <head>
        <title> Nh√¢n ma tr·∫≠n - Ph·∫ßn 2: T√≠nh to√°n tr√™n GPU | Huy's Blog</title>
        <meta charset="utf-8">
        <meta http-equiv="content-type" content="text/html;"><meta name=viewport content="initial-scale=1.0 maximum-scale=1.0">
        
        <link href="../css/inconsolata.css" rel="stylesheet" type="text/css">
        <link href="../css/theme.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="../css/highlight/tomorrow.css">
        <link rel="stylesheet" href="../css/fontello.css">
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/autosizing.js"></script>
        <script>
        hljs.initHighlightingOnLoad();
        </script>
    </head>
    <body>
      <div class="notice">N·ªôi dung tr√™n blog n√†y ƒë∆∞·ª£c c·∫≠p nh·∫≠t l·∫ßn cu·ªëi v√†o l√∫c <b>11:50 02/05/2017</b>.<br/>T·ª´ gi·ªù blog s·∫Ω chuy·ªÉn sang nh√† m·ªõi l√† <a href="https://thefullsnack.com">https://thefullsnack.com</a>. Mong c√°c b·∫°n gh√© ch∆°i <i class="icon icon-emo-coffee"></i></div>
        <div class="header">
            <a href="/"><i class="icon icon-emo-coffee"></i> Huy's Blog</a>
        </div>
        <div class="container">
            <div class="main">
                <h1 id="nh-n-ma-tr-n-ph-n-2-t-nh-to-n-tr-n-gpu">Nh√¢n ma tr·∫≠n - Ph·∫ßn 2: T√≠nh to√°n tr√™n GPU</h1>
<p>Sau khi vi·∫øt xong <a href="https://huytd.github.io/posts/nhan-ma-tran.html">b√†i ƒë·∫ßu ti√™n</a>, m√¨nh ti·∫øp t·ª•c t√¨m hi·ªÉu s√¢u h∆°n v·ªÅ ma tr·∫≠n v√† c·∫£m th·∫•y c·∫ßn ph·∫£i vi·∫øt th√™m m·ªôt (v√†i) b√†i n·ªØa v√¨ c√≥ qu√° nhi·ªÅu th·ª© hay ho khi ƒëi s√¢u v√†o.</p>
<p>Trong ph·∫ßn n√†y, m√¨nh gi·ªõi thi·ªáu v·ªÅ ph∆∞∆°ng ph√°p s·ª≠ d·ª•ng GPU ƒë·ªÉ th·ª±c hi·ªán ph√©p t√≠nh nh√¢n 2 ma tr·∫≠n (GPU Calculation), thay cho vi·ªác d√πng CPU truy·ªÅn th·ªëng, ƒë·ªÉ tƒÉng t·ªëc ƒë·ªô t√≠nh to√°n.</p>
<h2 id="t-i-sao-l-i-l-gpu-c-c-vi-c-t-nh-to-n-tr-n-gpu-sao-">T·∫°i sao l·∫°i l√† GPU? c√≥ c·∫£ vi·ªác t√≠nh to√°n tr√™n GPU sao?</h2>
<p>C√¢u tr·∫£ l·ªùi l√† c√≥, th∆∞a c√°c b·∫°n. Ch√∫ng ta ƒë·ªÅu bi·∫øt GPU l√† m·ªôt th√†nh ph·∫ßn trong card ƒë·ªì h·ªça, th∆∞·ªùng ƒë∆∞·ª£c gi·ªõi game th·ªß mua v·ªÅ c·∫Øm v√¥ cho m√°y t√≠nh x·ª≠ l√Ω ƒë·ªì h·ªça nhanh h∆°n. V·∫≠y thao t√°c x·ª≠ l√Ω ƒë·ªì h·ªça ·ªü ƒë√¢y l√† g√¨? </p>
<p>ƒê·ªÉ hi·ªÉu ƒë∆∞·ª£c ch·ª©c nƒÉng c·ªßa GPU, h√£y c√πng l√°i ch·ªß ƒë·ªÅ m·ªôt t√≠ sang lƒ©nh v·ª±c ƒë·ªì h·ªça m√°y t√≠nh, vi·∫øt ƒë·∫øn ƒë√¢y m√¨nh th·∫•y h∆°i b·ªã m√°u v√¨ d√π ƒë√£ t·ª´ b·ªè ng√†nh game ƒë∆∞·ª£c h∆°n 1 nƒÉm r·ªìi nh∆∞ng gi·ªù v·∫´n c√≥ c∆° h·ªôi quay l·∫°i vi·∫øt ti·∫øp v·ªÅ n√≥, h√™ h√™, l·∫°c ƒë·ªÅ t√≠ th√¥i, c√°c b·∫°n c≈©ng y√™n t√¢m v√¨ m√¨nh s·∫Ω kh√¥ng ƒë·ªÉ b√†i vi·∫øt n√†y th√†nh b√†i h∆∞·ªõng d·∫´n l√†m game g√¨ ƒë√¢u =)))</p>
<h3 id="m-y-t-nh-t-o-ra-h-nh-nh-nh-th-n-o-">M√°y t√≠nh t·∫°o ra h√¨nh ·∫£nh nh∆∞ th·∫ø n√†o?</h3>
<p>M·ªôt h√¨nh ·∫£nh tr√™n m√°y t√≠nh ƒë∆∞·ª£c c·∫•u t·∫°o th√†nh t·ª´ng pixel, ƒëi·ªÅu n√†y h·∫≥n ai c≈©ng bi·∫øt, nh∆∞ng l√†m th·∫ø n√†o ƒë·ªÉ m√°y t√≠nh hi·ªÉu v√† v·∫Ω ƒë∆∞·ª£c m·ªôt h√¨nh ·∫£nh th√†nh m·ªôt t·ªï h·ª£p c√°c pixel ƒë∆∞a l√™n m√†n h√¨nh qua s·ª± ch·ªâ ƒë·∫°o c·ªßa ch∆∞∆°ng tr√¨nh (application)?</p>
<p><img src="http://ithare.com/wp-content/uploads/BB_part114_BookChapter014h_v3.png" alt=""></p>
<center><em>Ngu·ªìn: <a href="http://ithare.com/game-graphics-101-rendering-pipeline/">http://ithare.com/game-graphics-101-rendering-pipeline/</a></em></center>

<p>Trong tr∆∞·ªùng h·ª£p l√† game th√¨ c√°c d·ªØ li·ªáu h√¨nh ·∫£nh (3d mesh, texture,...) s·∫Ω ƒë∆∞·ª£c load t·ª´ ƒëƒ©a (hard disk, file,...) v√† truy·ªÅn v√†o GPU. T·∫°i ƒë√¢y, GPU s·∫Ω ti·∫øn h√†nh ph√¢n t√≠ch v√† th·ª±c hi·ªán nh·ªØng c√¥ng vi·ªác t√≠nh to√°n c·∫ßn thi·∫øt ƒë·ªÉ chuy·ªÉn ch√∫ng th√†nh t·∫≠p h·ª£p c√°c pixel g·ª≠i tr·∫£ v·ªÅ CPU ƒë·ªÉ v·∫Ω ra m√†n h√¨nh m√°y t√≠nh (IO devices).</p>
<p>Qu√° tr√¨nh t√≠nh to√°n ƒë√≥ ·ªü trong GPU, ƒë∆∞·ª£c g·ªçi l√† <strong>Rendering Pipeline</strong>, trong h√¨nh minh h·ªça ·ªü tr√™n th√¨ d√¢y chuy·ªÅn v·∫≠n chuy·ªÉn c√°c kh·ªëi h·ªôp pixel kia ch√≠nh l√† pipeline.</p>
<h3 id="rendering-pipeline">Rendering Pipeline</h3>
<p>M·ªôt v·∫≠t th·ªÉ 3D trong m√°y t√≠nh ƒë∆∞·ª£c c·∫•u th√†nh t·ª´ nhi·ªÅu ƒë·ªânh, g·ªçi l√† <strong>vertex</strong>, m·∫£ng c√°c vertex ƒë∆∞·ª£c g·ªçi l√† <strong>vertices</strong> array.</p>
<p><img src="img/mesh_1.png" alt=""></p>
<p>H√¨nh tr√™n cho th·∫•y m·ªôt kh·ªëi h·ªôp ƒë∆∞·ª£c t·∫°o t·ª´ m·∫£ng $v$ g·ªìm c√°c ƒë·ªânh <code>$v_{0}, v_{1}, \ldots, v_{7}$</code></p>
<p>Trong m√°y t√≠nh, m·ªçi h√¨nh ·∫£nh t·ª´ ƒë∆°n gi·∫£n hay ph·ª©c t·∫°p ƒë·ªÅu ƒë∆∞·ª£c t·∫°o th√†nh t·ª´ c√°c vertices nh∆∞ v·∫≠y.</p>
<p><img src="img/mesh_2.png" alt=""></p>
<p>Render Pipeline l√† qu√° tr√¨nh x·∫£y ra trong GPU, khi n√≥ nh·∫≠n m·ªôt t·∫≠p h·ª£p c√°c vertices, tr·∫£i qua c√°c b∆∞·ªõc x·ª≠ l√Ω k·∫øt n·ªëi c√°c vertices l·∫°i v·ªõi nhau (vertex processing) th√†nh c√°c kh·ªëi 3D c∆° b·∫£n (th∆∞·ªùng l√† c√°c kh·ªëi tam gi√°c, g·ªçi l√† 3D primitives), sau ƒë√≥ ph√¢n t√≠ch (rasterization) c√°c h√¨nh kh·ªëi 3D n√†y th√†nh t·ª´ng m·∫£nh nh·ªè (fragments), th·ª±c hi·ªán vi·ªác t√≠nh to√°n t√¥ m√†u, ƒë·ªï b√≥ng,... cho c√°c kh·ªëi n√†y r·ªìi √°nh x·∫° n√≥ th√†nh m·∫£ng c√°c pixel t∆∞∆°ng ·ª©ng v·ªõi m√†n h√¨nh m√°y t√≠nh, g·ª≠i tr·∫£ v·ªÅ CPU ƒë·ªÉ ƒë∆∞a l√™n m√†n h√¨nh.</p>
<p>V√¨ quy tr√¨nh n√†y di·ªÖn ra li√™n t·ª•c v·ªõi t·ªëc ƒë·ªô c·ª±c k√¨ cao ƒë·ªÉ ƒë·∫£m b·∫£o cho vi·ªác hi·ªÉn th·ªã h√¨nh ·∫£nh l√™n m√†n h√¨nh di·ªÖn ra xuy√™n su·ªët v√† m∆∞·ª£t m√†, n√™n GPU ph·∫£i l√†m vi·ªác v·ªõi m·ªôt kh·ªëi l∆∞·ª£ng c√°c ph√©p t√≠nh c·ª±c k√¨ l·ªõn. N√≥i nh∆∞ v·∫≠y th√¨ kh√¥ng c√≥ nghƒ©a l√† CPU kh√¥ng c√≥ kh·∫£ nƒÉng d·ª±ng h√¨nh ·∫£nh ƒë·ªì h·ªça tr√™n m√°y t√≠nh, b·∫£n th√¢n CPU c≈©ng c√≥ th·ªÉ l√†m ƒë∆∞·ª£c nh∆∞ng s·∫Ω kh√¥ng ƒë·∫°t ƒë∆∞·ª£c performance nh∆∞ GPU, l√Ω do t·∫°i sao xin m·ªùi c√°c b·∫°n xem ti·∫øp.</p>
<h3 id="gpu-vs-cpu">GPU vs CPU</h3>
<p>H√¨nh sau so s√°nh ki·∫øn tr√∫c c·ªßa m·ªôt CPU so v·ªõi m·ªôt GPU:</p>
<p><img src="img/cpuvsgpu1.png" alt=""></p>
<p>C√°c b·∫°n c√≥ th·ªÉ th·∫•y kh·ªëi t√≠nh to√°n c·ªßa GPU nhi·ªÅu h∆°n CPU r·∫•t nhi·ªÅu l·∫ßn, v√¨ th·∫ø l√†m cho GPU c√≥ kh·∫£ nƒÉng t√≠nh to√°n cao h∆°n CPU.</p>
<p>Th√™m m·ªôt h√¨nh ·∫£nh n·ªØa ƒë·ªÉ so s√°nh s·ª± l·ª£i h·∫°i c·ªßa GPU, n·∫øu b·∫°n c√≥ m·ªôt m√°y t√≠nh c√≥ vi x·ª≠ l√Ω 4 nh√¢n th√¨ ƒë√¢y l√† s·ª± kh√°c bi·ªát ƒë·ªëi v·ªõi GPU:</p>
<p><img src="img/cpuvsgpu2.png" alt=""></p>
<p>Nh∆∞ng n·∫øu s·ª≠ d·ª•ng GPU l·ª£i h·∫°i nh∆∞ v·∫≠y th√¨ t·∫°i sao ng∆∞·ªùi ta kh√¥ng d√πng GPU ƒë·ªÉ thay th·∫ø CPU lu√¥n? C√¢u tr·∫£ l·ªùi l√† r·∫•t kh√≥, v√¨ vi·ªác debug tr√™n GPU kh√¥ng ƒë∆°n gi·∫£n nh∆∞ v·ªõi CPU, th√™m n·ªØa l√† GPU code ch·∫°y song song (parallel) n√™n c·∫ßn ph·∫£i c√≥ c√°c ph∆∞∆°ng ph√°p ƒë·ªÉ ph√¢n v√πng d·ªØ li·ªáu, li√™n l·∫°c, ƒë·ªìng b·ªô h√≥a gi·ªØa c√°c core n√™n c√°c thu·∫≠t to√°n x·ª≠ l√Ω tr√™n GPU c·ª±c k√¨ ph·ª©c t·∫°p.</p>
<p>ƒêo·∫°n video sau ƒë√¢y minh h·ªça s·ª± kh√°c bi·ªát v·ªÅ vi·ªác d√πng CPU v√† GPU ƒë·ªÉ v·∫Ω h√¨nh ·∫£nh, con robot m√†u v√†ng l√† CPU c√≤n c√°i m√°y b·ª± ch√† b√° kia l√† s·ª©c m·∫°nh th·ª±c s·ª± c·ªßa m·ªôt GPU.</p>
<iframe width="700" height="400" src="https://www.youtube.com/embed/-P28LKWTzrI" frameborder="0" allowfullscreen></iframe>

<h3 id="gpu-ch-d-ng-l-m-h-a-">GPU ch·ªâ d√πng l√†m ƒë·ªì h·ªça?</h3>
<p>V·ªõi s·ª± ph√°t tri·ªÉn c·ªßa lƒ©nh v·ª±c c√¥ng ngh·ªá th√¥ng tin hi·ªán nay, nh·ªØng c√¥ng vi·ªác y√™u c·∫ßu kh·∫£ nƒÉng t√≠nh to√°n c·ª±c k√¨ cao ƒë√£ b·∫Øt ƒë·∫ßu c·∫ßn ƒë·∫øn c√°c h·ªá th·ªëng m√°y t√≠nh c√≥ kh·∫£ nƒÉng x·ª≠ l√Ω m·∫°nh h∆°n, v√† ng∆∞·ªùi ta ƒë√£ b·∫Øt ƒë·∫ßu t√¨m ƒë·∫øn s·ª± tr·ª£ gi√∫p c·ªßa c√°c GPU trong c√¥ng vi·ªác t√≠nh to√°n, kh√¥ng ph·∫£i ch·ªâ ri√™ng CPU n·ªØa.</p>
<p>M·ªôt ·ª©ng d·ª•ng th·ª±c t·∫ø c√≥ l·∫Ω nhi·ªÅu ng∆∞·ªùi bi·∫øt ƒë·∫øn nh·∫•t ƒë√≥ l√† vi·ªác s·ª≠ d·ª•ng GPU ƒë·ªÉ &quot;ƒë√†o&quot; Bitcoin.</p>
<p><img src="https://media.amazonwebservices.com/blog/2016/p2_cool_gpus_1.png" alt=""></p>
<p>M·ªôt ·ª©ng d·ª•ng kh√°c th∆∞·ªùng th·∫•y n·ªØa l√† trong ng√†nh Machine Learning, ng∆∞·ªùi ta th∆∞·ªùng s·ª≠ d·ª•ng GPU ƒë·ªÉ gia tƒÉng t·ªëc ƒë·ªô t√≠nh to√°n ƒë·ªëi v·ªõi c√°c vector d·ªØ li·ªáu, v√¨ ƒë√¢y c≈©ng l√† m·ªôt ng√†nh ph·∫£i x·ª≠ l√Ω v·ªõi l∆∞·ª£ng d·ªØ li·ªáu c·ª±c k√¨ l·ªõn.</p>
<p>G√≥i EC2 P2 c·ªßa AWS c≈©ng h·ªó tr·ª£ GPU <a href="https://aws.amazon.com/blogs/aws/new-p2-instance-type-for-amazon-ec2-up-to-16-gpus/">https://aws.amazon.com/blogs/aws/new-p2-instance-type-for-amazon-ec2-up-to-16-gpus/</a></p>
<h2 id="t-nh-to-n-v-i-gpu-b-ng-c-ch-n-o-">T√≠nh to√°n v·ªõi GPU b·∫±ng c√°ch n√†o?</h2>
<p>C√≥ r·∫•t nhi·ªÅu c√°ch ƒë·ªÉ s·ª≠ d·ª•ng GPU l√†m c√¥ng c·ª• t√≠nh to√°n, b·∫°n c√≥ th·ªÉ kh·ªüi t·∫°o m·ªôt ·ª©ng d·ª•ng ƒë·ªì h·ªça, chuy·ªÉn ƒë·ªïi vector d·ªØ li·ªáu c·∫ßn t√≠nh to√°n th√†nh c√°c ma tr·∫≠n texture r·ªìi n·∫°p v√†o GPU, vi·∫øt c√°c Shader program (l√† m·ªôt d·∫°ng ch∆∞∆°ng tr√¨nh ch·∫°y tr√™n GPU, trong qu√° tr√¨nh fragment processing c·ªßa rendering pipeline) ƒë·ªÉ t√≠nh to√°n v√† tr·∫£ d·ªØ li·ªáu v·ªÅ l·∫°i CPU.</p>
<p>Tuy nhi√™n c√°ch l√†m tr√™n kh√° l√† ph·ª©c t·∫°p v√† d∆∞ th·ª´a (ph·∫£i kh·ªüi t·∫°o m√¥i tr∆∞·ªùng ƒë·ªì h·ªça, kh√¥ng c·∫ßn thi·∫øt, v√† ƒë√≥ l√† c√°ch l√†m th·ªß c√¥ng, kh√¥ng c√≥ g√¨ ƒë·∫£m b·∫£o, v√† b·ªã gi·ªõi h·∫°n b·ªüi kh·∫£ nƒÉng c·ªßa Shader program. </p>
<p>Ng√†y nay ch√∫ng ta c√≥ c√°c gi·∫£i ph√°p kh√°c, c√≥ th·ªÉ n√≥i l√† &quot;native&quot; h∆°n, ƒë√≥ l√† <strong>OpenCL</strong> v√† <strong>CUDA</strong>.</p>
<h3 id="cuda">CUDA</h3>
<p>Khi m·ªõi ƒë∆∞·ª£c ra m·∫Øt, <strong>CUDA</strong> l√† t√™n vi·∫øt t·∫Øt c·ªßa <strong>Compute Unified Device Architecture</strong> tuy nhi√™n v·ªÅ sau th√¨ Nvidia b·ªè h·∫≥n t√™n g·ªçi n√†y.</p>
<p><strong>CUDA</strong> l√† m·ªôt n·ªÅn t·∫£ng l·∫≠p tr√¨nh song song (parallel computing platform), cung c·∫•p cho ch√∫ng ta c√°c API tr√™n c√°c ng√¥n ng·ªØ nh∆∞ C/C++, Fortran, v√† v·ªÅ sau c√≤n xu·∫•t hi·ªán th√™m c√°c wrapper cho Java, Ruby, Python, Haskell... ƒë·ªÉ giao ti·∫øp v·ªõi c√°c GPU c·ªßa Nvidia v√† th·ª±c hi·ªán c√¥ng vi·ªác t√≠nh to√°n gi·ªëng nh∆∞ tr√™n CPU.</p>
<p>Quy tr√¨nh ho·∫°t ƒë·ªông c·ªßa m·ªôt ·ª©ng d·ª•ng CUDA kh√° l√† gi·ªëng v·ªõi rendering pipeline:</p>
<p><img src="img/cudaflow.png" alt=""></p>
<ol>
<li>Copy d·ªØ li·ªáu t·ª´ b·ªô nh·ªõ ch√≠nh v√†o b·ªô nh·ªõ GPU</li>
<li>CPU ch·ªâ th·ªã cho GPU th·ª±c hi·ªán t√≠nh to√°n</li>
<li>GPU th·ª±c hi·ªán t√≠nh to√°n song song tr√™n c√°c core c·ªßa n√≥</li>
<li>T√≠nh xong GPU g·ª≠i tr·∫£ d·ªØ li·ªáu v·ªÅ l·∫°i cho b·ªô nh·ªõ ch√≠nh</li>
</ol>
<p>CUDA c√≥ m·ªôt v√†i nh∆∞·ª£c ƒëi·ªÉm nh·∫•t ƒë·ªãnh, tuy nhi√™n ƒëi·ªÉm y·∫øu l·ªõn nh·∫•t c·ªßa n√≥ l√† ƒë∆∞·ª£c l√†m ra b·ªüi Nvidia n√™n ch·ªâ h·ªó tr·ª£ ch·∫°y tr√™n ph·∫ßn c·ª©ng c·ªßa Nvidia, v√† kh√¥ng ai mu·ªën c√¥ng ngh·ªá m√¨nh s·ª≠ d·ª•ng l·∫°i b·ªã ph·ª• thu·ªôc v√†o m·ªôt h√£ng s·∫£n xu·∫•t nh·∫•t ƒë·ªãnh n√†o h·∫øt (tr·ª´ tr∆∞·ªùng h·ª£p Apple =))) v·∫≠y cho n√™n ng∆∞·ªùi ta b·∫Øt ƒë·∫ßu t√¨m ƒë·∫øn m·ªôt gi·∫£i ph√°p t·ªïng qu√°t h∆°n, ƒë√≥ l√† <strong>OpenCL</strong></p>
<h3 id="opencl">OpenCL</h3>
<p><strong>Open Computing Language</strong> vi·∫øt t·∫Øt l√† <strong>OpenCL</strong> l√† m·ªôt framework gi√∫p c√°c l·∫≠p tr√¨nh vi√™n ph√°t tri·ªÉn c√°c ·ª©ng d·ª•ng m√† ch∆∞∆°ng tr√¨nh c√≥ th·ªÉ ch·∫°y ƒë∆∞·ª£c tr√™n nhi·ªÅu b·ªô x·ª≠ l√Ω nh∆∞ CPU, GPU, FPGA,...</p>
<p><img src="img/opencl.png" alt=""></p>
<p><strong>OpenCL</strong> l√† m·ªôt chu·∫©n m·ªü ƒë∆∞·ª£c Apple t·∫°o ra v√† trao quy·ªÅn ph√°t tri·ªÉn cho t·ªï ch·ª©c Khronos Group tr·ª© danh (t·ªï ch·ª©c ƒëang n·∫Øm quy·ªÅn ph√°t tri·ªÉn OpenGL). <strong>OpenCL</strong> ƒë∆∞·ª£c r·∫•t nhi·ªÅu h√£ng ph·∫ßn c·ª©ng h·ªó tr·ª£ nh∆∞ l√† AMD, Apple, ARM, IBM, Imagination Technologies, Intel, Nvidia, Qualcomm, Samsung,... ƒëi·ªÅu n√†y khi·∫øn cho OpenCL tr·ªü th√†nh m·ªôt ti√™u chu·∫©n chung cho c·∫£ ng√†nh c√¥ng nghi·ªáp, gi·ªëng nh∆∞ OpenGL v·∫≠y.</p>
<p>V√† trong b√†i vi·∫øt n√†y ch√∫ng ta s·∫Ω s·ª≠ d·ª•ng OpenCL ƒë·ªÉ implement thu·∫≠t to√°n nh√¢n ma tr·∫≠n tr√™n GPU. ƒê·ªÉ c√≥ th·ªÉ implement ƒë∆∞·ª£c th√¨ ƒë·∫ßu ti√™n ph·∫£i t√¨m hi·ªÉu r√µ h∆°n v·ªÅ OpenCL v√† c√°ch l·∫≠p tr√¨nh s·ª≠ d·ª•ng OpenCL.</p>
<h2 id="l-p-tr-nh-gpu-v-i-opencl">L·∫≠p tr√¨nh GPU v·ªõi OpenCL</h2>
<p>ƒê·∫ßu ti√™n ch√∫ng ta c·∫ßn hi·ªÉu c√°c kh√°i ni·ªám s·ª≠ d·ª•ng trong <strong>OpenCL</strong>.</p>
<h3 id="c-c-thu-t-ng-trong-opencl">C√°c thu·∫≠t ng·ªØ trong OpenCL</h3>
<p>C√°c th√†nh ph·∫ßn tham gia vi·ªác t√≠nh to√°n trong m·ªôt ·ª©ng d·ª•ng <strong>OpenCL</strong> l√† c√°c <strong>Compute Device</strong>, g·ªçi l√† c√°c thi·∫øt b·ªã t√≠nh to√°n. V√† c√°c thi·∫øt b·ªã t√≠nh to√°n n√†y c√≥ th·ªÉ l√† c√°c <strong>CPU</strong>, <strong>GPU</strong> ho·∫∑c c√°c thi·∫øt b·ªã kh√°c c√≥ t√≠nh nƒÉng t∆∞∆°ng t·ª± b√™n trong m√°y t√≠nh.</p>
<p><img src="img/computedevice.png" alt=""></p>
<p>Trong m·ªói m·ªôt <strong>Compute Device</strong> ch√∫ng ta c√≥ nhi·ªÅu <strong>Compute Unit</strong>, l√† c√°c core b√™n trong n√≥.</p>
<p><img src="img/computeunits.png" alt=""></p>
<p>V√† trong m·ªói <strong>Compute Unit</strong> (core) ta c√≥ nhi·ªÅu <strong>Processing Element</strong> tr·ª±c ti·∫øp nh·∫≠n l·ªánh ƒë·ªÉ t√≠nh to√°n.</p>
<h3 id="m-h-nh-l-m-vi-c-trong-opencl">M√¥ h√¨nh l√†m vi·ªác trong OpenCL</h3>
<p>M√¥ h√¨nh x·ª≠ l√Ω c·ªßa <strong>OpenCL</strong> g·ªìm c√≥ m·ªôt ch∆∞∆°ng tr√¨nh <strong>Host</strong> c√≥ nhi·ªám v·ª• ƒëi·ªÅu khi·ªÉn v√† li√™n l·∫°c v·ªõi nhi·ªÅu <strong>Compute Device</strong> theo s∆° ƒë·ªì sau:</p>
<p><img src="img/openclworkflow.png" alt=""></p>
<p>Khi th·ª±c hi·ªán x·ª≠ l√Ω, <strong>Host</strong> s·∫Ω kh·ªüi t·∫°o tr√™n m·ªói <strong>Compute Device</strong> m·ªôt <strong>Context</strong> ch·ª©a c√°c th√†nh ph·∫ßn nh∆∞ l√†: </p>
<ul>
<li>Th√¥ng tin device ƒëang ch·∫°y</li>
<li>Kernel (l√† ƒë∆°n v·ªã nh·ªè nh·∫•t c·ªßa qu√° tr√¨nh x·ª≠ l√Ω, nh∆∞ l√† m·ªôt h√†m)</li>
<li>Program Object (l√† ƒëo·∫°n code implement c·ªßa Kernel)</li>
<li>Command Queues (l√† queue c√°c l·ªánh ƒë∆∞·ª£c truy·ªÅn v√†o device t·ª´ host)</li>
<li>Memory Object (l√† ƒë·ªëi t∆∞·ª£ng ch·ª©a d·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c truy·ªÅn/nh·∫≠n qua l·∫°i gi·ªØa device v√† host)</li>
</ul>
<p>Thao t√°c copy d·ªØ li·ªáu t·ª´ <strong>Host</strong> t·ªõi <strong>Compute Device</strong> g·ªçi l√† thao t√°c <strong>ghi</strong> (writing), v√† thao t√°c copy d·ªØ li·ªáu ng∆∞·ª£c l·∫°i t·ª´ <strong>Compute Device</strong> v·ªÅ <strong>Host</strong> g·ªçi l√† <strong>ƒë·ªçc</strong> (reading).</p>
<p>ƒê√¢y l√† flow c·ªßa m·ªôt ch∆∞∆°ng tr√¨nh OpenCL th∆∞·ªùng th·∫•y:</p>
<ul>
<li><strong>B∆∞·ªõc 1:</strong> Ch·ªçn device c·∫ßn d√πng (v√≠ d·ª• nh∆∞: To√†n b·ªô GPU)</li>
<li><strong>B∆∞·ªõc 2:</strong> Kh·ªüi t·∫°o context</li>
<li><strong>B∆∞·ªõc 3:</strong> Kh·ªüi t·∫°o Command Queue cho t·ª´ng device</li>
<li><strong>B∆∞·ªõc 4:</strong> Bi√™n d·ªãch ch∆∞∆°ng tr√¨nh</li>
<li><strong>B∆∞·ªõc 5:</strong> T·∫°o c√°c kernel t·ª´ ch∆∞∆°ng tr√¨nh</li>
<li><strong>B∆∞·ªõc 6:</strong> C·∫•p ph√°t b·ªô nh·ªõ tr√™n t·ª´ng device</li>
<li><strong>B∆∞·ªõc 7:</strong> Ghi d·ªØ li·ªáu v√†o memory object tr√™n device</li>
<li><strong>B∆∞·ªõc 8:</strong> Th·ª±c hi·ªán x·ª≠ l√Ω c√°c kernel tr√™n device</li>
<li><strong>B∆∞·ªõc 9:</strong> G·ª≠i d·ªØ li·ªáu v·ªÅ l·∫°i host</li>
<li><strong>B∆∞·ªõc 10:</strong> Gi·∫£i ph√≥ng b·ªô nh·ªõ tr√™n device</li>
</ul>
<p>C√≥ th·ªÉ th·∫•y m√¥ h√¨nh tr√™n c√≥ ph·∫ßn ph·ª©c t·∫°p h∆°n <strong>CUDA</strong>. Nh∆∞ng l√†m vi·ªác v·ªõi <strong>OpenCL</strong> linh ho·∫°t h∆°n v√† kh√¥ng b·ªã gi·ªõi h·∫°n v·ªÅ m·∫∑t thi·∫øt b·ªã nh∆∞ <strong>CUDA</strong>.</p>
<p>Vi·ªác kh·ªüi ƒë·ªông m·ªôt <strong>kernel</strong> r·∫•t t·ªën k√©m, v√¨ th·∫ø l·ªùi khuy√™n ƒë∆∞·ª£c ƒë∆∞a ra l√† n√™n thi·∫øt k·∫ø m·ªói kernel l√†m nhi·ªÅu vi·ªác nh·∫•t c√≥ th·ªÉ.</p>
<h3 id="m-h-nh-qu-n-l-b-nh-c-a-opencl">M√¥ h√¨nh qu·∫£n l√Ω b·ªô nh·ªõ c·ªßa OpenCL</h3>
<h2 id="implement-m-t-ch-ng-tr-nh-opencl-n-gi-n">Implement m·ªôt ch∆∞∆°ng tr√¨nh OpenCL ƒë∆°n gi·∫£n</h2>
<p>V·∫≠y coi nh∆∞ xong ph·∫ßn l√Ω thuy·∫øt, gi·ªù ch√∫ng ta ƒëi v√†o ph·∫ßn th·ª±c h√†nh c∆° b·∫£n ƒë·ªÉ hi·ªÉu kƒ© h∆°n v·ªÅ c√°ch l·∫≠p tr√¨nh tr√™n GPU.</p>
<p>ƒê·ªÅ b√†i s·∫Ω l√†: <em>Implement ch∆∞∆°ng tr√¨nh t√≠nh t·ªïng t·ª´ 0 ƒë·∫øn 100 tri·ªáu</em></p>
<h3 id="implement-tr-n-cpu">Implement tr√™n CPU</h3>
<p>V·ªõi c√°ch n√†y th√¨ kh√¥ng c√≥ g√¨ ƒë·ªÉ b√†n r·ªìi, ƒë∆°n gi·∫£n ch√∫ng ta s·∫Ω implement m·ªôt v√≤ng <code>for</code> r·ªìi cho n√≥ ch·∫°y t·ª´ 0 ƒë·∫øn 100 tri·ªáu, c·ª© th·∫ø m√† c·ªông s·ªë v√†o.</p>
<pre><code>for (unsigned long long i = 0; i &lt; 100000000; i++) {
  val += i;
}
</code></pre><p>Ch√∫ng ta s·∫Ω th√™m v√†o m·ªôt ƒëo·∫°n code ƒë·ªÉ ƒëo th·ªùi gian ch∆∞∆°ng tr√¨nh b·ªè ra ƒë·ªÉ th·ª±c hi·ªán ph√©p t√≠nh tr√™n.</p>
<pre><code>clock_t begin = clock();

// Do something

clock_t end = clock();
double runtime = (double)(end - begin) / CLOCKS_PER_SEC;
</code></pre><p>H√†m <code>clock()</code> l·∫•y th·ªùi gian hi·ªán t·∫°i, c√≥ trong th∆∞ vi·ªán <code>time.h</code>, m·ª•c ƒë√≠ch c·ªßa ƒëo·∫°n code tr√™n l√† l·∫•y th·ªùi gian ·ªü v·ªã tr√≠ b·∫Øt ƒë·∫ßu x·ª≠ l√Ω, v√† th·ªùi gian ·ªü v·ªã tr√≠ sau khi k·∫øt th√∫c x·ª≠ l√Ω, tr·ª´ 2 s·ªë ƒë√≥ v·ªõi nhau ta c√≥ ƒë∆∞·ª£c th·ªùi gian c·∫ßn ƒë·ªÉ ch·∫°y ch∆∞∆°ng tr√¨nh.</p>
<p>ƒêo·∫°n implement ƒë·∫ßy ƒë·ªß s·∫Ω nh∆∞ sau:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

typedef unsigned long long fuckin_large;

int main() {
  clock_t begin = clock();

  fuckin_large val = 0;
  for (fuckin_large j = 0; j &lt; 100000000; j++) {
    val += j;
  }
  printf(&quot;Result: %llu\n&quot;, val);

  clock_t end = clock();
  double runtime = (double)(end - begin) / CLOCKS_PER_SEC;
  printf(&quot;Runtime: %lfms\n&quot;, runtime);
}
</code></pre><p>Ch·∫°y th·ª≠ ch∆∞∆°ng tr√¨nh tr√™n, output s·∫Ω c√≥ d·∫°ng nh∆∞ sau:</p>
<pre><code>Result: 4999999950000000
Runtime: 0.225600ms
</code></pre><p>D√≤ng ƒë·∫ßu l√† con s·ªë k·∫øt qu·∫£ sau khi ƒë√£ t√≠nh ra, d√≤ng th·ª© 2 cho bi·∫øt th·ªùi gian c·∫ßn ƒë·ªÉ th·ª±c hi·ªán ch∆∞∆°ng tr√¨nh. </p>
<p>M√¨nh c√≥ ch·∫°y th·ª≠ ch∆∞∆°ng tr√¨nh n√†y tr√™n c√°c m√°y MacBook Pro t·ª´ 2012 t·ªõi 2015, trung b√¨nh m·∫•t t·∫ßm <strong>0.2 mili gi√¢y</strong> ƒë·ªÉ t√≠nh ra k·∫øt qu·∫£.</p>
<p>Ti·∫øp theo h√£y th·ª≠ implement ch∆∞∆°ng tr√¨nh n√†y v·ªõi c√°ch x·ª≠ l√Ω t∆∞∆°ng t·ª± nh∆∞ng ch·∫°y tr√™n GPU xem t·ªëc ƒë·ªô ƒë∆∞·ª£c c·∫£i thi·ªán nh∆∞ th·∫ø n√†o nh√©.</p>
<h3 id="implement-tr-n-gpu">Implement tr√™n GPU</h3>
<p>ƒê·ªÉ implement m·ªôt ch∆∞∆°ng tr√¨nh d√πng OpenCL th√¨ ta c·∫ßn implement 2 ph·∫ßn: <strong>Host</strong> program v√† <strong>Kernel</strong> program.</p>
<p><img src="img/hostkernelsrc.png" alt=""></p>
<p><strong>Host</strong> l√† m·ªôt ch∆∞∆°ng tr√¨nh C/C++ c√≥ nhi·ªám v·ª• ƒë·ªçc file ch∆∞∆°ng tr√¨nh <strong>Kernel</strong> (ƒëu√¥i <code>*.cl</code>) v√† l√†m c√°c c√¥ng vi·ªác kh√°c nh∆∞ l√† kh·ªüi t·∫°o context, ch·ªçn device, build program object, memory object, th·ª±c thi kernel,... nh∆∞ ƒë√£ n√≥i ·ªü ph·∫ßn tr√™n.</p>
<h4 id="host-program">Host Program</h4>
<p><strong>B∆∞·ªõc 1: Kh·ªüi t·∫°o</strong></p>
<p>ƒê·∫ßu ti√™n <strong>Host</strong> c·∫ßn kh·ªüi t·∫°o c√°c bi·∫øn ƒë·ªÉ ch·ª©a c√°c ƒë·ªëi t∆∞·ª£ng c·∫ßn thi·∫øt nh∆∞ l√† <strong>Device</strong>, <strong>Context</strong>, <strong>Command Queue</strong>,...:</p>
<pre><code>cl_device_id device_id          = NULL;
cl_context context              = NULL;
cl_command_queue command_queue  = NULL;
cl_mem memobj                   = NULL;
cl_program program              = NULL;
cl_kernel kernel                = NULL;
cl_platform_id platform_id      = NULL;
cl_uint ret_num_devices;
cl_uint ret_num_platforms;
cl_int ret;
</code></pre><p><strong>B∆∞·ªõc 2: ƒê·ªçc Kernel Source</strong></p>
<p>Ti·∫øp theo ch√∫ng ta ƒë·ªçc file <strong>Kernel</strong> source v√† l∆∞u v√†o m·ªôt file pointer:</p>
<pre><code>FILE *fp;
char fileName[]   = &quot;./sum.cl&quot;;
char *source_str;
size_t source_size;

fp = fopen(fileName, &quot;r&quot;);
if (!fp) {
  fprintf(stderr, &quot;Failed to load kernel\n&quot;);
  exit(1);
}
source_str  = (char*)malloc(MAX_SOURCE_SIZE);
source_size = fread(source_str, 1, MAX_SOURCE_SIZE, fp);
fclose(fp);
</code></pre><p>Trong v√≠ d·ª• n√†y th√¨ file <strong>Kernel</strong> c·ªßa ch√∫ng ta l√† <code>sum.cl</code></p>
<p><strong>B∆∞·ªõc 3: Kh·ªüi t·∫°o Context v√† c√°c th√†nh ph·∫ßn li√™n quan</strong></p>
<p>Sau khi ƒë√£ c√≥ source code c·ªßa <strong>Kernel</strong>, ta ti·∫øn h√†nh ch·ªçn device v√† kh·ªüi t·∫°o context, bi√™n d·ªãch source code c·ªßa kernel th√†nh <strong>Program Object</strong> </p>
<pre><code>ret = clGetPlatformIDs(1, &amp;platform_id, &amp;ret_num_platforms);
ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_DEFAULT, 1, &amp;device_id, &amp;ret_num_devices);

context       = clCreateContext(NULL, 1, &amp;device_id, NULL, NULL, &amp;ret);
command_queue = clCreateCommandQueue(context, device_id, 0, &amp;ret);
program       = clCreateProgramWithSource(context, 1, 
                                         (const char **)&amp;source_str, 
                                         (const size_t *)&amp;source_size, 
                                         &amp;ret);
ret           = clBuildProgram(program, 1, &amp;device_id, 
                                           NULL, NULL, NULL);
kernel        = clCreateKernel(program, &quot;hello&quot;, &amp;ret);
</code></pre><p><strong>B∆∞·ªõc 4: C·∫•p ph√°t b·ªô nh·ªõ tr√™n Compute Device</strong></p>
<p>Sau ƒë√≥ c·∫•p ph√°t b·ªô nh·ªõ cho Compute Device trong Context th√¥ng qua h√†m <code>clCreateBuffer</code> v√† <code>clSetKernelArg</code> ƒë·ªÉ ch·ªâ ƒë·ªãnh v√πng nh·ªõ n√†y t∆∞∆°ng ·ª©ng v·ªõi tham s·ªë n√†o khi truy·ªÅn v√†o kernel.</p>
<pre><code>memobj = clCreateBuffer(context, CL_MEM_READ_WRITE, 
                        sizeof(cl_mem), NULL, &amp;ret);
ret = clSetKernelArg(kernel, 0, sizeof(cl_mem), (void*)&amp;memobj);
</code></pre><p>Ngo√†i ra, ch√∫ng ta c√≥ th·ªÉ truy·ªÅn gi√° tr·ªã v√†o cho c√°c tham s·ªë th√¥ng qua h√†m <code>clEnqueueWriteBuffer</code>:</p>
<pre><code>ret = clEnqueueWriteBuffer(command_queue, memobj_A, CL_TRUE, 0, MATRIX_SIZE * MATRIX_SIZE * sizeof(cl_mem), A, 0, NULL, NULL);
</code></pre><p><strong>B∆∞·ªõc 5: Ch·∫°y Kernel v√† ƒê·ªçc k·∫øt qu·∫£</strong></p>
<p>ƒê·∫øn b∆∞·ªõc n√†y ch√∫ng ta s·ª≠ d·ª•ng h√†m <code>clEnqueueTask</code> ƒë·ªÉ g√°n <strong>Command Queue</strong> ƒë√£ t·∫°o v√†o cho <strong>Kernel</strong>. Sau khi ƒë∆∞·ª£c g√°n th√¨ <strong>Kernel</strong> s·∫Ω kh·ªüi ƒë·ªông v√† b·∫Øt ƒë·∫ßu x·ª≠ l√Ω tr√™n c√°c <strong>Processing Elements</strong> tr√™n <strong>Compute Device</strong> (·ªü ƒë√¢y c√≥ th·ªÉ l√† GPU c·ªßa ch√∫ng ta).</p>
<pre><code>ret = clEnqueueTask(command_queue, kernel, 0, NULL, NULL);
</code></pre><p>ƒê·ªÉ l·∫•y d·ªØ li·ªáu ra sau khi <strong>Kernel</strong> ho√†n th√†nh vi·ªác t√≠nh to√°n, ch√∫ng ta d√πng h√†m <code>clEnqueueReadBuffer</code>:</p>
<pre><code>ret = clEnqueueReadBuffer(command_queue, memobj, CL_TRUE, 0, sizeof(cl_mem), val, 0, NULL, NULL);
</code></pre><p>Gi√° tr·ªã <code>CL_TRUE</code> truy·ªÅn v√†o h√†m n√†y l√† cho tham s·ªë <code>cl_bool blocking_read</code>, tham s·ªë n√†y cho bi·∫øt h√†m <code>clEnqueueReadBuffer</code> s·∫Ω block kh√¥ng cho <strong>Host</strong> program th·ª±c hi·ªán ti·∫øp cho ƒë·∫øn khi n√≥ nh·∫≠n ƒë∆∞·ª£c gi√° tr·ªã tr·∫£ v·ªÅ sau khi <strong>Kernel</strong> ho√†n th√†nh.</p>
<p>ƒê√¢y c≈©ng l√† b∆∞·ªõc m√† ch√∫ng ta c·∫ßn s·ª≠ d·ª•ng h√†m <code>clock()</code> ƒë·ªÉ t√≠nh to√°n th·ªùi gian x·ª≠ l√Ω c·ªßa <strong>Kernel</strong>.</p>
<pre><code>clock_t begin = clock();

// Do something

clock_t end = clock();
double runtime = (double)(end - begin) / CLOCKS_PER_SEC;
</code></pre><p><strong>B∆∞·ªõc 6: Gi·∫£i ph√≥ng b·ªô nh·ªõ</strong></p>
<p>K·∫øt th√∫c ch∆∞∆°ng tr√¨nh, ch√∫ng ta gi·∫£i ph√≥ng t·∫•t c·∫£ c√°c ƒë·ªëi t∆∞·ª£ng ƒë√£ t·∫°o ra ƒë·ªÉ tr√°nh b·ªã memory leak.</p>
<pre><code>ret = clFlush(command_queue);
ret = clFinish(command_queue);
ret = clReleaseKernel(kernel);
ret = clReleaseProgram(program);
ret = clReleaseMemObject(memobj);
ret = clReleaseCommandQueue(command_queue);
ret = clReleaseContext(context);

free(source_str);
</code></pre><p>ƒê√¢y l√† ƒëo·∫°n code implement ƒë·∫ßy ƒë·ªß c·ªßa <strong>Host</strong> program l√†m c√¥ng vi·ªác t√≠nh t·ªïng theo ƒë·ªÅ b√†i ƒë√£ cho:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;OpenCL/opencl.h&gt;
#include &lt;time.h&gt;

#define MAX_SOURCE_SIZE (0x100000)

int main() {
  cl_device_id device_id = NULL;
  cl_context context = NULL;
  cl_command_queue command_queue = NULL;
  cl_mem memobj = NULL;
  cl_program program = NULL;
  cl_kernel kernel = NULL;
  cl_platform_id platform_id = NULL;
  cl_uint ret_num_devices;
  cl_uint ret_num_platforms;
  cl_int ret;

  cl_ulong val[1];

  FILE *fp;
  char fileName[] = &quot;./sum.cl&quot;;
  char *source_str;
  size_t source_size;

  fp = fopen(fileName, &quot;r&quot;);
  if (!fp) {
    fprintf(stderr, &quot;Failed to load kernel\n&quot;);
    exit(1);
  }
  source_str = (char*)malloc(MAX_SOURCE_SIZE);
  source_size = fread(source_str, 1, MAX_SOURCE_SIZE, fp);
  fclose(fp);

  ret = clGetPlatformIDs(1, &amp;platform_id, &amp;ret_num_platforms);
  ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_DEFAULT, 1, &amp;device_id, &amp;ret_num_devices);

  context = clCreateContext(NULL, 1, &amp;device_id, NULL, NULL, &amp;ret);
  command_queue = clCreateCommandQueue(context, device_id, 0, &amp;ret);
  memobj = clCreateBuffer(context, CL_MEM_READ_WRITE, sizeof(cl_mem), NULL, &amp;ret);
  program = clCreateProgramWithSource(context, 1, (const char **)&amp;source_str, (const size_t *)&amp;source_size, &amp;ret);
  ret = clBuildProgram(program, 1, &amp;device_id, NULL, NULL, NULL);
  kernel = clCreateKernel(program, &quot;hello&quot;, &amp;ret);

  ret = clSetKernelArg(kernel, 0, sizeof(cl_mem), (void*)&amp;memobj);

  clock_t begin = clock();

  ret = clEnqueueTask(command_queue, kernel, 0, NULL, NULL);

  ret = clEnqueueReadBuffer(command_queue, memobj, CL_TRUE, 0, sizeof(cl_mem), val, 0, NULL, NULL);

  clock_t end = clock();
  double runtime = (double)(end - begin) / CLOCKS_PER_SEC;

  ret = clFlush(command_queue);
  ret = clFinish(command_queue);
  ret = clReleaseKernel(kernel);
  ret = clReleaseProgram(program);
  ret = clReleaseMemObject(memobj);
  ret = clReleaseCommandQueue(command_queue);
  ret = clReleaseContext(context);

  printf(&quot;Result: %llu\n&quot;, val[0]);
  printf(&quot;Runtime: %lfms\n&quot;, runtime);

  free(source_str);

  return 0;
}
</code></pre><h4 id="kernel-program">Kernel Program</h4>
<p>Ti·∫øp ƒë·∫øn ch√∫ng ta implement <strong>Kernel</strong>, ƒë√¢y l√† ƒëo·∫°n ch∆∞∆°ng tr√¨nh s·∫Ω ƒë∆∞·ª£c <strong>Host</strong> n·∫°p v√†o <strong>Program Object</strong> ƒë·ªÉ th·ª±c hi·ªán x·ª≠ l√Ω tr√™n GPU.</p>
<p>Ch∆∞∆°ng tr√¨nh n√†y s·∫Ω ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a b·∫±ng c√°c t·ª´ kh√≥a <code>kernel</code>. Ta truy·ªÅn v√†o m·ªôt bi·∫øn con tr·ªè ƒë·ªÉ ti·∫øp nh·∫≠n d·ªØ li·ªáu ƒë·∫ßu ra, ch∆∞∆°ng tr√¨nh n√†y s·ª≠ d·ª•ng ph∆∞∆°ng ph√°p t√≠nh b·∫±ng c√°ch ch·∫°y m·ªôt v√≤ng l·∫∑p for, c√≥ th·ªÉ implement nh∆∞ sau:</p>
<pre><code>kernel void hello(global ulong *val) {
  size_t i = get_global_id(0);
  for (ulong j = 0; j &lt; 100000000; j++) {
    val[i] += j;
  }
}
</code></pre><p>Bi·∫øn <code>i</code> trong ch∆∞∆°ng tr√¨nh tr√™n l√† id c·ªßa ti·∫øn tr√¨nh kernel ƒë∆∞·ª£c kh·ªüi t·∫°o trong l√∫c th·ª±c thi, ch√∫ng ta c·∫ßn ph·∫£i l·∫•y ch√≠nh x√°c id n√†y ƒë·ªÉ g·ª≠i tr·∫£ d·ªØ li·ªáu v·ªÅ cho <strong>Host</strong>.</p>
<p>ƒê·∫∑c ƒëi·ªÉm c·ªßa kernel l√† c√°c bi·∫øn, tham s·ªë truy·ªÅn v√†o ƒë·ªÅu mutable v√† ch√∫ng ta kh√¥ng c·∫ßn return d·ªØ li·ªáu (v√¨ ·ªü host ƒë√£ c√≥ m·ªôt b∆∞·ªõc ƒë·ªçc d·ªØ li·ªáu t·ª´ memory object ra r·ªìi).</p>
<h2 id="implement-thu-t-to-n-nh-n-ma-tr-n-tr-n-gpu">Implement thu·∫≠t to√°n nh√¢n ma tr·∫≠n tr√™n GPU</h2>
<p>(Coming soon...)</p>
<div class='other-tags'><b>Tags:</b> <a class='topic-tag' href='https://huytd.github.io/tags/algorithm.html'>algorithm</a><a class='topic-tag' href='https://huytd.github.io/tags/math.html'>math</a><a class='topic-tag' href='https://huytd.github.io/tags/gpu.html'>gpu</a></div>
                <div class="copyright">
                B·∫°n ƒë∆∞·ª£c t√πy √Ω b·∫•m like, tr√≠ch d·∫´n ho·∫∑c copy, post l·∫°i, nh∆∞ng vui l√≤ng ghi r√µ ngu·ªìn v√† t√°c gi·∫£ v√† kh√¥ng l√†m thay ƒë·ªïi n·ªôi dung b√†i vi·∫øt. N·∫øu kh√¥ng l√†m v·∫≠y, m√¨nh hy v·ªçng t·ª´ nay v·ªÅ sau b·∫°n s·∫Ω lu√¥n c·∫£m th·∫•y c·∫Øn r·ª©t l∆∞∆°ng t√¢m, ƒÉn kh√¥ng ngon, ng·ªß kh√¥ng y√™n. üòÜ
                </div>
                <!-- Comment -->
                <div class="comments">
                  <div id="comment-loading" class="loading"></div>
                  <div id="login-box" class="login">
                    B·∫°n c·∫ßn <button onclick="login()">Login</button> ƒë·ªÉ comment
                  </div>
                  <div id="comment-box" class="comment-input">
                    <div class="avatar">
                      <img id="user-avatar" src="" width="32" height="32"/>
                    </div>
                    <div class="input">
                      <textarea id="comment-content" onkeyup="autoSizing(this)" onkeydown="submitComment(event)" placeholder="Comment g√µ v√†o ƒë√¢y :D"></textarea>
                      <span>G√µ xong nh·∫•n <kbd>Ctrl</kbd> + <kbd>Enter</kbd> ƒë·ªÉ g·ª≠i.</span>
                    </div>
                  </div>
                  <ul id="comment-list" class="comment-list"></ul>
                </div>
                <!-- End Comment -->
            </div>
        </div>
	    <div class="footer">
        <p><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://thefullsnack.com/img/by-nc-sa.png" /></a></p>
            <p>Created with <a href="http://github.com/huytd/azeroth-js">azeroth.js</a></p>
            <div class="social">
                <a target="_blank" href="http://facebook.com/kingbazoka"><i class="icon-facebook-squared"></i></a>
                <a target="_blank" href="http://twitter.com/huydotnet"><i class="icon-twitter-squared"></i></a>
                <a target="_blank" href="http://github.com/huytd"><i class="icon-github-squared"></i></a>
                <a target="_blank" href="https://thefullsnack.com"><i class="icon-emo-coffee"></i></a>
            </div>
        </div>
        <script type="text/javascript" async src="https://cdn.rawgit.com/mathjax/MathJax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            skipTags: ["script","noscript","style","textarea"]
          }
        });
        </script>
        <script src="https://www.gstatic.com/firebasejs/3.8.0/firebase.js"></script>
        <script>
          // Initialize Firebase
          var config = {
            apiKey: "AIzaSyA1PnIAlJJ-U6iQJMNnCOknBuziBqGMYcY",
            authDomain: "huys-blog-comment.firebaseapp.com",
            databaseURL: "https://huys-blog-comment.firebaseio.com",
            projectId: "huys-blog-comment",
            storageBucket: "huys-blog-comment.appspot.com",
            messagingSenderId: "317330376829"
          };
          firebase.initializeApp(config);
        </script>
        <script>
          let provider = new firebase.auth.GoogleAuthProvider();
          let auth = firebase.auth();
          let currentUser = null;
          let postCommentURL = 'posts/nhan-ma-tran-2/comments';

          auth.onAuthStateChanged(function(user) {
            document.getElementById("comment-loading").style.display = "none";
            if (user) {
              currentUser = user;
              // Logged in
              document.getElementById("login-box").style.display = "none";
              document.getElementById("comment-box").style.display = "flex";
              document.getElementById("user-avatar").setAttribute("src", user.photoURL);
            } else {
              // Not login yet
              document.getElementById("comment-box").style.display = "none";
              document.getElementById("login-box").style.display = "block";
            }
          });

          const login = function() {
            auth.signInWithPopup(provider)
              .then(function(result) {
              }).catch(function(err) {
              });
          };

          const encodeHTML = function(s) {
            return s.replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/>/g, '&gt;');
          };

          const saveNewComment = function(comment) {
            if (!currentUser) {
              return;
            }
            let commentData = {
              user: currentUser.displayName,
              avatar: currentUser.photoURL,
              time: (new Date()).getTime(),
              message: encodeHTML(comment)
            };
            database.ref(postCommentURL).push(commentData);
            document.getElementById("comment-content").value = "";
          };

          const submitComment = function(e) {
            let keyCode = e.which || e.keyCode;
            let ctrlCode = e.ctrlKey || e.metaKey;
            if (keyCode === 13 && ctrlCode) {
              let comment = document.getElementById("comment-content").value;
              saveNewComment(comment);
            }
          };

          const filterURLinComment = function(comment) {
            return comment.replace(/(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g, "<a target='_blank' rel='noopener noreferrer' href='$1'>$1</a>");
          };

          const addNewComment = function(user, avatar, time, comment) {
            let commentFiltered = encodeHTML(comment);
            commentFiltered = filterURLinComment(commentFiltered);
            let d = new Date(time);
            let commentTime = d.toLocaleTimeString() + ' ' + d.toLocaleDateString();
            let html = '<div class="avatar">' +
              '   <img src="' + avatar + '" width="32" height="32"/>' +
              ' </div>' +
              '<div class="comment">' +
              '  <div class="metadata"><b>' + user + '</b> l√∫c <span>' + commentTime + '</span></div>' +
              '  <div class="content">' + commentFiltered
              '  </div>' +
              '</div>';
            let li = document.createElement('li');
            li.innerHTML = html;
            document.getElementById("comment-list").append(li);
          };

          let database = firebase.database();
          let posts = database.ref(postCommentURL).orderByChild('time');
          posts.on('child_added', function(data) {
            addNewComment(data.val().user, data.val().avatar, data.val().time, data.val().message);
          });
        </script>
    </body>
</html>
