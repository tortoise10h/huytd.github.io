#+TITLE: Rust for the Web
#+DATE: 25-05-2017 11:30:20
#+OPTIONS: timestamp:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/hack.css" />
#+HTML_HEAD: <script async src="https://www.googletagmanager.com/gtag/js?id=UA-121604637-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-121604637-1'); </script>
#+HTML_LINK_HOME: /

/"Can we create web apps in Rust?"/ - Many people asked. So am I.

My primary goal when I started learning Rust is to make a move from my
ducky JavaScript tech stack (Node.js Express), that means, to make web
apps in Rust.

And after a year, I learned something. So I write this post to tell you
my journal into Rust Web Programming.

There are many approach to creating web apps in Rust, for example,
compile Rust code to client-side JavaScript, writing a RESTful API, or
building an isomorphic web app just like it's 2012. I'll go one by one.

** Client-side JavaScript in Rust
   :PROPERTIES:
   :CUSTOM_ID: client-side-javascript-in-rust
   :END:

The first thing that came to my mind is to have component-based
architecture just like React. This mean, you need to find a way to run
Rust code on the web browser.

Thanks to ASM.js and WebAssembly, this is possible, with
[[https://users.rust-lang.org/t/compiling-to-the-web-with-rust-and-emscripten/7627][a quick setup]], you can compile your Rust code to ASM.js/WebAssembly in
few minutes.

Now, for the component-based architecture, I just created some macros to
wrap over the [[https://crates.io/crates/stdweb][stdweb]] crate and
rendering HTML elements via browser's DOM API.

[[https://github.com/huytd/rust-webapp-template/blob/master/src/main.rs#L13-L58]]

Don't be scared if you think I just posted an alien language. The
=component!= macro is used to define a custom element. The
=mount_component!= macro is used to append an element to the document,
and =html!= macro is to create an element from HTML string.

Here is how I use it:

#+BEGIN_EXAMPLE
    component!(AppComponent => {
        init: {
            let e: Element = html!("
            <div>
                <p>
                    <span>Hello</span>
                    <span>World</span>
                </p>
                <GreenButton />
            </div>
            ");

            let mut button = GreenButton::new();
            mount_component!(e, "GreenButton", button);

            e
        },
        render: |this: &Element| {
        }
    });

    component!(GreenButton => {
        init: {
            let button = document().create_element("button");
            button.add_event_listener(move |_: ClickEvent| {
                js! {
                    alert("Yo! This is the Green Button!");
                }
            });
            button
        },
        render: |this: &Element| {
            this.set_text_content("This is a button");
        }
    });

    fn main() {
        stdweb::initialize();

        let mut app = AppComponent::new();
        mount_component!(document(), "#root", app);

        stdweb::event_loop();
    }
#+END_EXAMPLE

Who need React anymore when you can even write an =onClick= event in
your Rust code :D (just kidding).

You might want to [[https://github.com/huytd/rust-webapp-template][take a look at the full project]] to see in details how to use =stdweb= with
these macros.

** RESTful API in Rust
   :PROPERTIES:
   :CUSTOM_ID: restful-api-in-rust
   :END:

If you don't want to give up your JavaScript frontend, this is the
better approach: Just write an API server in Rust to make it work with
your exist frontend.

There are a handful number of frameworks available for you to choose.
Let's take a look at [[http://www.arewewebyet.org/][AreWeWebYet]].

For people who prefer to have slimmer framework,
[[https://crates.io/crates/tiny_http][tiny-http]] is the best choice.

For simplicty, you can use
[[https://github.com/nickel-org/nickel.rs][nickel.rs]], it's one of the
most lightweight framework in Rust that inspired by Node's Express.

For HTTP/2 support, [[https://github.com/mlalic/solicit][solicit]] is
the only choice you have right now.

Personally, I prefer to use [[https://rocket.rs][Rocket]] as it is a
very good framework that has many features, but still keep your code
simple, with very elegant syntax. It also added built-in TLS support
recently. The only minus point for this framework is it required to use
nightly Rust version.

This is the simple route handler for a =GET= method in =Rocket=.

#+BEGIN_EXAMPLE
    #[get("/posts", format = "application/json")]
    fn get_posts(page: i64) -> Json<Value> {
        Json(json!({
            "result": []
        }))
    }
#+END_EXAMPLE

I usually let =Rocket= serve the static files for me, just like what I
did in Express:

#+BEGIN_EXAMPLE
    #[get("/")]
    fn index() -> io::Result<NamedFile> {
        NamedFile::open("www/index.html")
    }

    #[get("/<file..>", rank = 5)]
    fn files(file: PathBuf) -> Option<NamedFile> {
        NamedFile::open(Path::new("www/").join(file)).ok()
    }
#+END_EXAMPLE

So I can put all my frontend code inside =www= folder, and access it
along my RESTful API. For example, a typical project struct will be:

#+BEGIN_EXAMPLE
    ├── Cargo.toml
    ├── README.md
    ├── src
    │   ├── main.rs
    │   └── ...Rust code here...
    └── www
        ├── index.html
        ├── main.js
        ├── package.json
        ├── webpack.config.js
        └── ...JavaScript code here...
#+END_EXAMPLE

To work with database, it's a good idea to use
[[https://diesel.rs][Diesel]].

If you want to see a =Rocket= + =Diesel= + =React= project in action, I
will shamelessly plug one of [[https://news.kipalog.com][my side project
here]] and [[https://github.com/huytd/codedaily-v3][its source code]] on
Github.

#+attr_html: :width 500px
[[file:img/rust-kipalog.png]]

Please feel free take a look or use it if it good enough for you.

** Isomorphic web app in Rust
   :PROPERTIES:
   :CUSTOM_ID: isomorphic-web-app-in-rust
   :END:

The last one, my favorite one, like it's 2012, when I started my
programming career with my first PHP job.

No more single page applications, no more client-side rendered UI. No
more broken web pages when people
[[https://www.quora.com/Why-do-some-people-disable-JavaScript-in-their-browser][disabled
JavaScript on their browsers]].

=Rocket= and many other frameworks has the ability to render the HTML
templates after binding some data into it.

#+BEGIN_EXAMPLE
    #[get("/")]
    fn index() -> Template {
        let news = fetch_from(RSS_URL).ok().expect("Could not read RSS");
        Template::render("index", &news)
    }
#+END_EXAMPLE

I recently built a [[https://codedaily.xyz][Hacker News reader]] using
=Rocket= + =Handlebars= templates, you can take a look at
[[https://github.com/huytd/hackernews-rss-reader][its source code here]]
(hey, I know, it's a shameless PR again).

#+attr_html: :width 500px
[[file:img/rust-hackernews.png]]

--------------

I hope the three approaches I listed here will be helpful if you're the
one who asking: /"Can Rust make webs?"/. Each one has pros and cons, and
depends on your project, you can pick one of them or mixing them all
together.

Please feel free to leave a comment on [[https://news.ycombinator.com/item?id=15014557][Hacker News]] or [[https://www.reddit.com/r/rust/comments/6tqzka/rust_for_the_web/][Reddit]] to share your thoughts.
