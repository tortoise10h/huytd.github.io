#+TITLE: Thread for WebAssembly
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/hack.css" />
#+HTML_HEAD: <script async src="https://www.googletagmanager.com/gtag/js?id=UA-121604637-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-121604637-1'); </script>
#+HTML_LINK_HOME: /

Starting from Chrome 70, there's a =pthread= support added, you can enable it in =chrome://flags= screen. At the time of writing, there's only Chrome that support =pthread=.

#+ATTR_HTML: :class full-width round :width 900px
[[https://developers.google.com/web/updates/images/2018/10/WasmThreads3.png]]

Or using [[https://github.com/GoogleChrome/OriginTrials][Origin Trials]] to enable the features right on your user's browser, by a token attached to your domain.

* How to use?

To use, just write your program as normal, then when you compile, supply the =USE_PTHREADS= and =PTHREAD_POOL_SIZE= into =emcc= command:

#+BEGIN_SRC 
emcc -O2 -s USE_PTHREADS=1 -s PTHREAD_POOL_SIZE=2 -o test.js test.c
#+END_SRC

* Under the hood

Browsers already has support for thread, they're called =Web Workers=, but they do not share mutable data between them, they rely on =message passing= for communication.

#+BEGIN_QUOTE
*Sidenote:* Message passing with Web Workers has a big performance impact: https://www.loxodrome.io/post/web-worker-performance/
#+END_QUOTE

WebAssembly threads can share data between threads, the shared memory implemented using =SharedArrayBuffer=. Each thread in the =thread pool= runs in a =Web Worker=. That's why we supply the =PTHREAD_POOL_SIZE= in the compiling step.

Make sure =thread pool size= is equals to the maximum number of threads your application needs, or thread creation _may_ fail. But don't make it too large, you'll create unnecessary =Web Workers= that do nothing, but still using 

#+BEGIN_QUOTE
*Question:* I heard that =SharedArrayBuffer= is disabled due to the [[https://meltdownattack.com/][Spectre and Meltdown]], then what will happen to WebAssembly Threads?

*Answer:* The vulnerabilities will be fixed eventually, then browsers will start shipping with =SharedArrayBuffer= enabled by default again, everything should be fine. In the meantime, we can just enable it ourselves.
#+END_QUOTE

-----

*Bonus:* A great article about how Rust implemented thread support for WebAssembly thru =wasm-bindgen=, they even have a working demo but there are still so many works to do: https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html
